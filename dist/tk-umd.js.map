{"version":3,"file":"tk-umd.js","sources":["tk.js"],"sourcesContent":["// Parsing, tokeninzing, etc\n'use strict';\n\nvar EMPTY_STRING = '';\n\nvar prefixes = {\n    '<': {\n        'exec': 'parent'\n    },\n    '~': {\n        'exec': 'root'\n    },\n    '%': {\n        'exec': 'placeholder'\n    }\n},\nprefixList = Object.keys(prefixes);\n\nvar separators = {\n    '.': {\n        'exec': 'property'\n        },\n    ',': {\n        'exec': 'collection'\n        }\n},\nseparatorList = Object.keys(separators);\n\nvar containers = {\n    // '[': {\n    //     'closer': ']',\n    //     'exec': '??'\n    //     },\n    '(': {\n        'closer': ')',\n        'exec': 'call'\n        },\n    '{': {\n        'closer': '}',\n        'exec': 'property'\n        }\n},\ncontainerList = Object.keys(containers);\n\nvar wildCardMatch = function(template, str){\n    var pos = template.indexOf('*'),\n        parts = template.split('*', 2),\n        match = true;\n    if (parts[0]){\n        match = match && str.substr(0, parts[0].length) === parts[0];\n    }\n    if (parts[1]){\n        match = match && str.substr(pos+1) === parts[1];\n    }\n    return match;\n};\nvar specials = '[\\\\' + ['*'].concat(prefixList).concat(separatorList).concat(containerList).join('\\\\').replace(/\\\\?\\./, '') + ']';\nvar specialRegEx = new RegExp(specials);\n\nvar isObject = function(val) {\n    if (val === null) { return false;}\n    return ( (typeof val === 'function') || (typeof val === 'object') );\n};\n\nvar flatten = function(ary){\n    ary = Array.isArray(ary) ? ary : [ary];\n    return ary.reduce(function(a, b) {\n      return a.concat(b);\n    },[]);\n};\n\nvar useCache = true,\n    cache = {};\n\n/*\n *  Scan input string from left to right, one character at a time. If a special character\n *  is found (one of \"separators\" or \"containers\"), either store the accumulated word as\n *  a token or else begin watching input for end of token (finding a closing character for\n *  a container or the end of a collection). If a container is found, call tokenize\n *  recursively on string within container.\n */\nvar tokenize = function (str){\n    if (useCache && cache[str]){ return cache[str]; }\n\n    var tokens = [],\n        mods = {},\n        strLength = str.length,\n        word = '',\n        substr = '',\n        i = 0,\n        opener = '',\n        closer = '',\n        separator = '',\n        collection = [],\n        depth = 0;\n\n    // console.log('Parsing:', str);\n\n    for (i = 0; i < strLength; i++){\n        if (depth > 0){\n            // Scan for closer\n            str[i] === opener && depth++;\n            str[i] === closer.closer && depth--;\n\n            if (depth > 0){\n                substr += str[i];\n            }\n            // TODO: handle comma-separated elements when depth === 1, process as function arguments\n            else {\n                if (i+1 < strLength && separators[str[i+1]] && separators[str[i+1]].exec === 'collection'){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                else if (collection[0]){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    tokens.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                substr = '';\n            }\n        }\n        else if (str[i] in prefixes){\n            mods.has = true;\n            if (mods[prefixes[str[i]].exec]) { mods[prefixes[str[i]].exec]++; }\n            else { mods[prefixes[str[i]].exec] = 1; }\n        }\n        else if (str[i] in separators){\n            separator = separators[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (separator.exec === 'property'){\n                // word is a plain property or end of collection\n                if (collection[0] !== undefined){\n                    // we are gathering a collection, so add last word to collection and then store\n                    word && collection.push(word);\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    // word is a plain property\n                    word && tokens.push(word);\n                }\n            }\n            else if (separator.exec === 'collection'){\n                // word is a collection\n                word && collection.push(word);\n            }\n            word = '';\n        }\n        else if (str[i] in containers){\n            // found opener, initiate scan for closer\n            closer = containers[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (collection[0] !== undefined){\n                // we are gathering a collection, so add last word to collection and then store\n                word && collection.push(word);\n            }\n            else {\n                // word is a plain property\n                word && tokens.push(word);\n            }\n            word = '';\n            opener = str[i];\n            depth++;\n        }\n        else {\n            // still accumulating property name\n            word += str[i];\n        }\n    }\n    // add trailing word to tokens, if present\n    if (word && mods.has){\n        word = {'w': word, 'mods': mods};\n        mods = {};\n    }\n    if (collection[0] !== undefined){\n        // we are gathering a collection, so add last word to collection and then store\n        word && collection.push(word);\n        tokens.push(collection);\n    }\n    else {\n        // word is a plain property\n        word && tokens.push(word);\n    }\n\n    // depth != 0 means mismatched containers\n    if (depth !== 0){ return undefined; }\n\n    useCache && (cache[str] = tokens);\n    return tokens;\n};\n\n// var getContext = function getContext(context, valueStack, word){\n//  if (!prefixes[word[0]]){\n//      return context;\n//  }\n//  var counter = 0,\n//      prefix,\n//      newContext;\n//  while (prefix = prefixes[word[counter]]){\n//      if (prefix.exec === 'parent'){\n//          newContext = valueStack[counter + 1];\n//      }\n//      counter++;\n//  }\n//  return newContext;\n// };\n\n// var cleanWord = function cleanWord(word){\n//  if(!prefixes[word[0]]){\n//      return word;\n//  }\n//  var len = word.length;\n//  for (var i = 1; i < len; i++){\n//      if (!prefixes[word[i]]){\n//          return word.substr(i);\n//      }\n//  }\n//  return '';\n// }\n\nvar resolvePath = function (obj, path, newValue, args, valueStack){\n    var change = newValue !== undefined,\n        tk = [],\n        tkLength = 0,\n        tkLastIdx = 0,\n        valueStackLength = 1,\n        i = 0,\n        prev = obj,\n        curr = '',\n        currLength = 0,\n        contextProp,\n        idx = 0,\n        context = obj,\n        ret,\n        newValueHere = false;\n\n    if (typeof path === 'string' && !path.match(specialRegEx)){\n        tk = path.split('.');\n        tkLength = tk.length;\n        while (prev !== undefined && i < tkLength){\n            if (i === EMPTY_STRING){ prev = undefined; }\n            else if (change){\n                if (i === tkLength - 1){\n                    prev[tk[i]] = newValue;\n                }\n            }\n            prev = prev[tk[i]];\n            i++;\n        }\n        return prev;\n    }\n\n    tk = typeof path === 'string' ? tokenize(path) : path.t ? path.t : [path];\n    tkLength = tk.length;\n    if (tkLength === 0) { return undefined; }\n    tkLastIdx = tkLength - 1;\n\n    if (typeof valueStack === 'undefined'){\n        valueStack = [obj]; // Initialize valueStack with original data object; length already init to 1\n    }\n    else {\n        valueStackLength = valueStack.length;\n    }\n\n    // Converted Array.reduce into while loop, still using \"prev\", \"curr\", \"idx\"\n    // as loop values\n    while (prev !== undefined && idx < tkLength){\n        curr = tk[idx];\n        newValueHere = (change && (idx === tkLastIdx));\n\n        if (typeof curr === 'string'){\n            if (curr.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else {\n                if (newValueHere){\n                    console.log('newValue:', newValue);\n                    context[curr] = newValue;\n                    console.log('after set:', context[curr]);\n                    if (context[curr] !== newValue){ return undefined; } // new value failed to set\n                }\n                ret = context[curr];\n\n            }\n        }\n        else {\n            if (Array.isArray(curr)){\n                // call resolvePath again with base value as evaluated value so far and\n                // each element of array as the path. Concat all the results together.\n                ret = [];\n                currLength = curr.length\n                for (i = 0; i < currLength; i++){\n                    contextProp = resolvePath(context, curr[i], newValue, args, valueStack.concat());\n                    if (typeof contextProp === 'undefined') { console.log('UNDEF!'); return undefined; }\n                    console.log('contextProp:', contextProp);\n\n                    if (newValueHere){\n                        if (curr[i].t && curr[i].exec === 'property'){\n                            console.log('PROP', context[contextProp]);\n                            context[contextProp] = newValue;\n                        } else {\n                            console.log('NOT PROP', contextProp);\n                            ret = ret.concat(contextProp);\n                        }\n                    }\n                    else {\n                        if (curr[i].t && curr[i].exec === 'property'){\n                            ret = ret.concat(context[contextProp]);\n                        } else {\n                            ret = ret.concat(contextProp);\n                        }\n                    }\n                }\n            }\n            else if (typeof curr === 'undefined' || typeof prev === 'undefined'){\n                ret = undefined;\n            }\n            else if (curr.w){\n                // this word token has modifiers, modify current context\n                if (curr.mods.parent){\n                    context = valueStack[valueStackLength - 1 - curr.mods.parent];\n                    if (typeof context === 'undefined') { return undefined; }\n                }\n                if (curr.mods.root){\n                    // Reset context and valueStack, start over at root in this context\n                    context = valueStack[0];\n                    valueStack = [context];\n                    valueStackLength = 1;\n                }\n                if (curr.mods.placeholder){\n                    if (curr.w.length === 0) { return undefined; }\n                    var placeInt = Number.parseInt(curr.w) - 1;\n                    if (typeof args[placeInt] === 'undefined'){ return undefined; }\n                    // Force args[placeInt] to String, won't attempt to process\n                    // arg of type function, array, or plain object\n                    curr.w = args[placeInt].toString();\n                    delete(curr.mods.placeholder); // Once value has been replaced, don't want to re-process this entry\n                    delete(curr.mods.has);\n                }\n\n                // Repeat basic string property processing with word and modified context\n                if (typeof context[curr.w] !== 'undefined') {\n                    if (newValueHere){ context[curr.w] = newValue; }\n                    ret = context[curr.w];\n                }\n                else if (typeof context === 'function'){\n                    ret = curr.w;\n                }\n                else if (curr.w.indexOf('*') >-1){\n                    ret = [];\n                    for (var prop in context){\n                        if (context.hasOwnProperty(prop) && wildCardMatch(curr.w, prop)){\n                            if (newValueHere){ context[prop] = newValue; }\n                            ret.push(context[prop]);\n                        }\n                    }\n                }\n                else { return undefined; }\n            }\n            else if (curr.exec === 'property'){\n                if (newValueHere){\n                    context[resolvePath(context, curr, newValue, args, valueStack.concat())] = newValue;\n                }\n                ret = context[resolvePath(context, curr, newValue, args, valueStack.concat())];\n            }\n            else if (curr.exec === 'call'){\n                // TODO: handle params for function\n                var callArgs = resolvePath(context, curr, newValue, args, valueStack.concat());\n                if (callArgs === undefined){\n                    ret = context.apply(valueStack[valueStackLength - 2]);\n                }\n                else if (Array.isArray(callArgs)){\n                    ret = context.apply(valueStack[valueStackLength - 2], callArgs);\n                }\n                else {\n                    ret = context.call(valueStack[valueStackLength - 2], callArgs);\n                }\n            }\n        }\n        valueStack.push(ret);\n        valueStackLength++;\n        context = ret;\n        prev = ret;\n        idx++;\n    }\n    return context;\n};\n\nvar scanForValue = function(obj, val, savePath, path){\n    var i, len, prop, more;\n\n    path = path ? path : '';\n\n    if (obj === val){\n        return savePath(path); // true -> keep looking; false -> stop now\n    }\n    else if (Array.isArray(obj)){\n        len = obj.length;\n        for(i = 0; i < len; i++){\n            more = scanForValue(obj[i], val, savePath, path + '.' + i);\n            if (!more){ return; }\n        }\n        return true; // keep looking\n    }\n    else if (isObject(obj)) {\n        for (prop in obj){\n            if (obj.hasOwnProperty(prop)){\n                more = scanForValue(obj[prop], val, savePath, path + '.' + prop);\n                if (!more){ return; }\n            }\n        }\n        return true; // keep looking\n    }\n    // Leaf node (string, number, character, boolean, etc.), but didn't match\n    return true; // keep looking\n};\n\nexport var getTokens = function(path){\n    return {t: tokenize(path)};\n};\n\nexport var getPath = function (obj, path){\n    var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : [];\n    return resolvePath(obj, path, undefined, args);\n};\n\nexport var setPath = function(obj, path, val){\n    var args = arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : [],\n        ref = resolvePath(obj, path, val, args);\n    console.log('setPath final:', ref);\n    if (Array.isArray(ref)){\n        return ref.indexOf(undefined) === -1;\n    }\n    return typeof ref !== 'undefined';\n};\n\nexport var getPathFor = function(obj, val, oneOrMany){\n    var retVal = [];\n    var savePath = function(path){\n        retVal.push(path.substr(1));\n        if(!oneOrMany || oneOrMany === 'one'){\n            retVal = retVal[0];\n            return false;\n        }\n        return true;\n    };\n    scanForValue(obj, val, savePath);\n    return retVal[0] ? retVal : undefined;\n};\n\nexport var setOptions = function(options){\n    if (options.prefixes){\n        for (var p in options.prefixes){\n            if (options.prefixes.hasOwnProperty(p)){\n                prefixes[p] = options.prefixes[p];\n            }\n        }\n    }\n    if (options.separators){\n        for (var s in options.separators){\n            if (options.separators.hasOwnProperty(s)){\n                separators[s] = options.separators[s];\n            }\n        }\n    }\n    if (options.containers){\n        for (var c in options.containers){\n            if (options.containers.hasOwnProperty(c)){\n                containers[c] = options.containers[c];\n            }\n        }\n    }\n    if (typeof options.cache !== 'undefined'){\n        useCache = !!options.cache;\n    }\n};\n"],"names":["EMPTY_STRING","prefixes","prefixList","Object","keys","separators","separatorList","containers","containerList","wildCardMatch","template","str","pos","indexOf","parts","split","match","substr","length","specials","concat","join","replace","specialRegEx","RegExp","isObject","val","useCache","cache","tokenize","tokens","mods","strLength","word","i","opener","closer","separator","collection","depth","exec","push","has","undefined","resolvePath","obj","path","newValue","args","valueStack","change","tk","tkLength","tkLastIdx","valueStackLength","prev","curr","currLength","contextProp","idx","context","ret","newValueHere","t","prop","hasOwnProperty","log","Array","isArray","w","parent","root","placeholder","placeInt","Number","parseInt","toString","callArgs","apply","call","scanForValue","savePath","len","more","getTokens","getPath","arguments","prototype","slice","setPath","ref","getPathFor","oneOrMany","retVal","setOptions","options","p","s","c"],"mappings":"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","sourceRoot":"/source/"}