{"version":3,"file":"tk-umd.js","sources":["tk.js"],"sourcesContent":["// Parsing, tokeninzing, etc\n'use strict';\n\nvar prefixes = {\n    '<': {\n        'exec': 'parent'\n    },\n    '~': {\n        'exec': 'root'\n    },\n    '%': {\n        'exec': 'placeholder'\n    }\n},\nprefixList = Object.keys(prefixes);\n\nvar separators = {\n    '.': {\n        'exec': 'property'\n        },\n    ',': {\n        'exec': 'collection'\n        }\n},\nseparatorList = Object.keys(separators);\n\nvar containers = {\n    // '[': {\n    //     'closer': ']',\n    //     'exec': '??'\n    //     },\n    '(': {\n        'closer': ')',\n        'exec': 'call'\n        },\n    '{': {\n        'closer': '}',\n        'exec': 'property'\n        }\n},\ncontainerList = Object.keys(containers);\n\nvar wildCardMatch = function(template, str){\n    var pos = template.indexOf('*'),\n        parts = template.split('*', 2),\n        match = true;\n    if (parts[0]){\n        match = match && str.substr(0, parts[0].length) === parts[0];\n    }\n    if (parts[1]){\n        match = match && str.substr(pos+1) === parts[1];\n    }\n    return match;\n};\n\n\nvar isObject = function(val) {\n    if (val === null) { return false;}\n    return ( (typeof val === 'function') || (typeof val === 'object') );\n};\n\nvar flatten = function(ary){\n    ary = Array.isArray(ary) ? ary : [ary];\n    return ary.reduce(function(a, b) {\n      return a.concat(b);\n    },[]);\n};\n\n/*\n *  Scan input string from left to right, one character at a time. If a special character\n *  is found (one of \"separators\" or \"containers\"), either store the accumulated word as\n *  a token or else begin watching input for end of token (finding a closing character for\n *  a container or the end of a collection). If a container is found, call tokenize\n *  recursively on string within container.\n */\nvar tokenize = function (str){\n    var tokens = [],\n        mods = {},\n        strLength = str.length,\n        word = '',\n        substr = '',\n        i,\n        opener, closer, separator,\n        collection = [],\n        depth = 0;\n\n    // console.log('Parsing:', str);\n\n    for (i = 0; i < strLength; i++){\n        if (depth > 0){\n            // Scan for closer\n            str[i] === opener && depth++;\n            str[i] === closer.closer && depth--;\n\n            if (depth > 0){\n                substr += str[i];\n            }\n            // TODO: handle comma-separated elements when depth === 1, process as function arguments\n            else {\n                if (i+1 < strLength && separators[str[i+1]] && separators[str[i+1]].exec === 'collection'){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                else if (collection[0]){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    tokens.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                substr = '';\n            }\n        }\n        else if (str[i] in prefixes){\n            mods.has = true;\n            if (mods[prefixes[str[i]].exec]) { mods[prefixes[str[i]].exec]++; }\n            else { mods[prefixes[str[i]].exec] = 1; }\n        }\n        else if (str[i] in separators){\n            separator = separators[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (separator.exec === 'property'){\n                // word is a plain property or end of collection\n                if (collection[0] !== undefined){\n                    // we are gathering a collection, so add last word to collection and then store\n                    word && collection.push(word);\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    // word is a plain property\n                    word && tokens.push(word);\n                }\n            }\n            else if (separator.exec === 'collection'){\n                // word is a collection\n                word && collection.push(word);\n            }\n            word = '';\n        }\n        else if (closer = containers[str[i]]){\n            // found opener, initiate scan for closer\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (collection[0] !== undefined){\n                // we are gathering a collection, so add last word to collection and then store\n                word && collection.push(word);\n            }\n            else {\n                // word is a plain property\n                word && tokens.push(word);\n            }\n            word = '';\n            opener = str[i];\n            depth++;\n        }\n        else {\n            // still accumulating property name\n            word += str[i];\n        }\n    }\n    // add trailing word to tokens, if present\n    if (word && mods.has){\n        word = {'w': word, 'mods': mods};\n        mods = {};\n    }\n    if (collection[0] !== undefined){\n        // we are gathering a collection, so add last word to collection and then store\n        word && collection.push(word);\n        tokens.push(collection);\n    }\n    else {\n        // word is a plain property\n        word && tokens.push(word);\n    }\n    return depth === 0 ? tokens : undefined; // depth != 0 means mismatched containers\n};\n\n// var getContext = function getContext(context, valueStack, word){\n// \tif (!prefixes[word[0]]){\n// \t\treturn context;\n// \t}\n// \tvar counter = 0,\n// \t\tprefix,\n// \t\tnewContext;\n// \twhile (prefix = prefixes[word[counter]]){\n// \t\tif (prefix.exec === 'parent'){\n// \t\t\tnewContext = valueStack[counter + 1];\n// \t\t}\n// \t\tcounter++;\n// \t}\n// \treturn newContext;\n// };\n\n// var cleanWord = function cleanWord(word){\n// \tif(!prefixes[word[0]]){\n// \t\treturn word;\n// \t}\n// \tvar len = word.length;\n// \tfor (var i = 1; i < len; i++){\n// \t\tif (!prefixes[word[i]]){\n// \t\t\treturn word.substr(i);\n// \t\t}\n// \t}\n// \treturn '';\n// }\n\nvar resolvePath = function (obj, path, newValue, args, valueStack){\n    valueStack = valueStack || [obj]; // Initialize valueStack with original data object\n    args = args || []; // args defaults to empty array\n\n    var change = newValue !== undefined,\n        val,\n        tk,\n        i,\n        root = valueStack[valueStack.length -1]; // Root is an alias for original data object\n\n    tk = typeof path === 'string' ? tokenize(path) : path.t ? path.t : [path];\n\n    return tk.length === 0 ? undefined : tk.reduce(function(prev, curr, idx){\n        var context = valueStack[0],\n            ret,\n            lastToken = (idx === (tk.length - 1)),\n            newValueHere = (change && lastToken);\n        if (typeof curr === 'undefined' || typeof prev === 'undefined'){\n            ret = undefined;\n        }\n        else if (typeof curr === 'string'){\n            // Cannot do \".hasOwnProperty\" here since that breaks when testing\n            // for functions defined on prototypes (e.g. [1,2,3].sort())\n            if (typeof context[curr] !== 'undefined') {\n                if (newValueHere){ context[curr] = newValue; }\n                ret = context[curr];\n            }\n            else if (curr.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (Array.isArray(curr)){\n            // call resolvePath again with base value as evaluated value so far and\n            // each element of array as the path. Concat all the results together.\n            ret = [];\n            for (i = 0; curr[i] !== undefined; i++){\n                if (newValueHere){\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        context[resolvePath(context, curr[i], newValue, args, valueStack.concat())] = newValue;\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n                else {\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n            }\n        }\n        else if (curr.w){\n            // this word token has modifiers, modify current context\n            if (curr.mods.parent){\n                context = valueStack[curr.mods.parent];\n                if (typeof context === 'undefined') { return undefined; }\n            }\n            if (curr.mods.root){\n                // Reset context and valueStack, start over at root in this context\n                context = root;\n                valueStack = [root];\n            }\n            if (curr.mods.placeholder){\n                if (curr.w.length === 0) { return undefined; }\n                var placeInt = Number.parseInt(curr.w) - 1;\n                if (typeof args[placeInt] === 'undefined'){ return undefined; }\n                // Force args[placeInt] to String, won't attempt to process\n                // arg of type function, array, or plain object\n                curr.w = args[placeInt].toString();\n                delete(curr.mods.placeholder); // Once value has been replaced, don't want to re-process this entry\n                delete(curr.mods.has);\n            }\n\n            // Repeat basic string property processing with word and modified context\n            if (context.hasOwnProperty(curr.w)) {\n                if (newValueHere){ context[curr.w] = newValue; }\n                ret = context[curr.w];\n            }\n            else if (typeof context === 'function'){\n                ret = curr.w;\n            }\n            else if (curr.w.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr.w, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (curr.exec === 'property'){\n            if (newValueHere){\n                context[resolvePath(context, curr, newValue, args, valueStack.concat())] = newValue;\n            }\n            ret = context[resolvePath(context, curr, newValue, args, valueStack.concat())];\n        }\n        else if (curr.exec === 'call'){\n            // TODO: handle params for function\n            var callArgs = resolvePath(context, curr, newValue, args, valueStack.concat());\n            if (callArgs === undefined){\n                ret = context.apply(valueStack[1]);\n            }\n            else if (Array.isArray(callArgs)){\n                ret = context.apply(valueStack[1], callArgs);\n            }\n            else {\n                ret = context.call(valueStack[1], callArgs);\n            }\n        }\n        valueStack.unshift(ret);\n        return ret;\n    }.bind(this), obj);\n};\n\nvar scanForValue = function(obj, val, savePath, path){\n    var i, len, prop, more;\n\n    path = path ? path : '';\n\n    if (obj === val){\n        return savePath(path); // true -> keep looking; false -> stop now\n    }\n    else if (Array.isArray(obj)){\n        len = obj.length;\n        for(i = 0; i < len; i++){\n            more = scanForValue(obj[i], val, savePath, path + '.' + i);\n            if (!more){ return; }\n        }\n        return true; // keep looking\n    }\n    else if (isObject(obj)) {\n        for (prop in obj){\n            if (obj.hasOwnProperty(prop)){\n                more = scanForValue(obj[prop], val, savePath, path + '.' + prop);\n                if (!more){ return; }\n            }\n        }\n        return true; // keep looking\n    }\n    // Leaf node (string, number, character, boolean, etc.), but didn't match\n    return true; // keep looking\n};\n\nexport var getPath = function (obj, path){\n    var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : [];\n    return resolvePath(obj, path, undefined, args);\n};\n\nexport var setPath = function(obj, path, val){\n    var args = arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : [],\n        ref = resolvePath(obj, path, val, args);\n    if (Array.isArray(ref)){\n        return ref.indexOf(undefined) === -1;\n    }\n    return typeof ref !== 'undefined';\n};\n\nexport var getPathFor = function(obj, val, oneOrMany){\n    var retVal = [];\n    var savePath = function(path){\n        retVal.push(path.substr(1));\n        if(!oneOrMany || oneOrMany === 'one'){\n            retVal = retVal[0];\n            return false;\n        }\n        return true;\n    };\n    scanForValue(obj, val, savePath);\n    return retVal[0] ? retVal : undefined;\n};\n\nexport var setOptions = function(options){\n    if (options.prefixes){\n        for (var p in options.prefixes){\n            if (options.prefixes.hasOwnProperty(p)){\n                prefixes[p] = options.prefixes[p];\n            }\n        }\n    }\n    if (options.separators){\n        for (var s in options.separators){\n            if (options.separators.hasOwnProperty(s)){\n                separators[s] = options.separators[s];\n            }\n        }\n    }\n    if (options.containers){\n        for (var c in options.containers){\n            if (options.containers.hasOwnProperty(c)){\n                containers[c] = options.containers[c];\n            }\n        }\n    }\n};\n"],"names":["prefixes","separators","containers","wildCardMatch","template","str","pos","indexOf","parts","split","match","substr","length","isObject","val","tokenize","tokens","mods","strLength","word","i","opener","closer","separator","collection","depth","exec","push","has","undefined","resolvePath","obj","path","newValue","args","valueStack","change","tk","root","t","reduce","prev","curr","idx","context","ret","lastToken","newValueHere","prop","hasOwnProperty","Array","isArray","concat","w","parent","placeholder","placeInt","Number","parseInt","toString","callArgs","apply","call","unshift","bind","scanForValue","savePath","len","more","getPath","arguments","prototype","slice","setPath","ref","getPathFor","oneOrMany","retVal","setOptions","options","p","s","c"],"mappings":"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","sourceRoot":"/source/"}