{"version":3,"file":"tk-umd.js","sources":["tk.js"],"sourcesContent":["// Parsing, tokeninzing, etc\n'use strict';\n\nvar EMPTY_STRING = '';\n\nvar prefixes = {\n    '<': {\n        'exec': 'parent'\n    },\n    '~': {\n        'exec': 'root'\n    },\n    '%': {\n        'exec': 'placeholder'\n    }\n},\nprefixList = Object.keys(prefixes);\n\nvar separators = {\n    '.': {\n        'exec': 'property'\n        },\n    ',': {\n        'exec': 'collection'\n        }\n},\nseparatorList = Object.keys(separators);\n\nvar containers = {\n    // '[': {\n    //     'closer': ']',\n    //     'exec': '??'\n    //     },\n    '(': {\n        'closer': ')',\n        'exec': 'call'\n        },\n    '{': {\n        'closer': '}',\n        'exec': 'property'\n        }\n},\ncontainerList = Object.keys(containers);\n\nvar wildCardMatch = function(template, str){\n    var pos = template.indexOf('*'),\n        parts = template.split('*', 2),\n        match = true;\n    if (parts[0]){\n        match = match && str.substr(0, parts[0].length) === parts[0];\n    }\n    if (parts[1]){\n        match = match && str.substr(pos+1) === parts[1];\n    }\n    return match;\n};\nvar specials = '[\\\\' + ['*'].concat(prefixList).concat(separatorList).concat(containerList).join('\\\\').replace(/\\\\?\\./, '') + ']';\nvar specialRegEx = new RegExp(specials);\n\nvar isObject = function(val) {\n    if (val === null) { return false;}\n    return ( (typeof val === 'function') || (typeof val === 'object') );\n};\n\nvar flatten = function(ary){\n    ary = Array.isArray(ary) ? ary : [ary];\n    return ary.reduce(function(a, b) {\n      return a.concat(b);\n    },[]);\n};\n\nvar useCache = true,\n    cache = {};\n\n/*\n *  Scan input string from left to right, one character at a time. If a special character\n *  is found (one of \"separators\" or \"containers\"), either store the accumulated word as\n *  a token or else begin watching input for end of token (finding a closing character for\n *  a container or the end of a collection). If a container is found, call tokenize\n *  recursively on string within container.\n */\nvar tokenize = function (str){\n    if (useCache && cache[str]){ return cache[str]; }\n\n    var tokens = [],\n        mods = {},\n        strLength = str.length,\n        word = '',\n        substr = '',\n        i = 0,\n        opener = '',\n        closer = '',\n        separator = '',\n        collection = [],\n        depth = 0;\n\n    // console.log('Parsing:', str);\n\n    for (i = 0; i < strLength; i++){\n        if (depth > 0){\n            // Scan for closer\n            str[i] === opener && depth++;\n            str[i] === closer.closer && depth--;\n\n            if (depth > 0){\n                substr += str[i];\n            }\n            // TODO: handle comma-separated elements when depth === 1, process as function arguments\n            else {\n                if (i+1 < strLength && separators[str[i+1]] && separators[str[i+1]].exec === 'collection'){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                else if (collection[0]){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    tokens.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                substr = '';\n            }\n        }\n        else if (str[i] in prefixes){\n            mods.has = true;\n            if (mods[prefixes[str[i]].exec]) { mods[prefixes[str[i]].exec]++; }\n            else { mods[prefixes[str[i]].exec] = 1; }\n        }\n        else if (str[i] in separators){\n            separator = separators[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (separator.exec === 'property'){\n                // word is a plain property or end of collection\n                if (collection[0] !== undefined){\n                    // we are gathering a collection, so add last word to collection and then store\n                    word && collection.push(word);\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    // word is a plain property\n                    word && tokens.push(word);\n                }\n            }\n            else if (separator.exec === 'collection'){\n                // word is a collection\n                word && collection.push(word);\n            }\n            word = '';\n        }\n        else if (str[i] in containers){\n            // found opener, initiate scan for closer\n            closer = containers[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (collection[0] !== undefined){\n                // we are gathering a collection, so add last word to collection and then store\n                word && collection.push(word);\n            }\n            else {\n                // word is a plain property\n                word && tokens.push(word);\n            }\n            word = '';\n            opener = str[i];\n            depth++;\n        }\n        else {\n            // still accumulating property name\n            word += str[i];\n        }\n    }\n    // add trailing word to tokens, if present\n    if (word && mods.has){\n        word = {'w': word, 'mods': mods};\n        mods = {};\n    }\n    if (collection[0] !== undefined){\n        // we are gathering a collection, so add last word to collection and then store\n        word && collection.push(word);\n        tokens.push(collection);\n    }\n    else {\n        // word is a plain property\n        word && tokens.push(word);\n    }\n\n    // depth != 0 means mismatched containers\n    if (depth !== 0){ return undefined; }\n\n    useCache && (cache[str] = tokens);\n    return tokens;\n};\n\n// var getContext = function getContext(context, valueStack, word){\n//  if (!prefixes[word[0]]){\n//      return context;\n//  }\n//  var counter = 0,\n//      prefix,\n//      newContext;\n//  while (prefix = prefixes[word[counter]]){\n//      if (prefix.exec === 'parent'){\n//          newContext = valueStack[counter + 1];\n//      }\n//      counter++;\n//  }\n//  return newContext;\n// };\n\n// var cleanWord = function cleanWord(word){\n//  if(!prefixes[word[0]]){\n//      return word;\n//  }\n//  var len = word.length;\n//  for (var i = 1; i < len; i++){\n//      if (!prefixes[word[i]]){\n//          return word.substr(i);\n//      }\n//  }\n//  return '';\n// }\n\nvar resolvePath = function (obj, path, newValue, args, valueStack){\n    var change = newValue !== undefined,\n        tk = typeof path === 'string' ? tokenize(path) : path.t ? path.t : [path],\n        tkLength = tk.length,\n        tkLastIdx = tkLength - 1,\n        i = 0,\n        prev = obj,\n        curr = '',\n        idx = 0,\n        context = obj,\n        ret,\n        newValueHere = false;\n\n    if (tkLength === 0) { return undefined; }\n    \n    if (typeof path === 'string' && typeof newValue === 'undefined' && !path.match(specialRegEx)){\n        while (prev !== undefined && i < tkLength){\n            if (i === EMPTY_STRING){ prev = undefined; }\n            else { prev = prev[tk[i]]; }\n            i++;\n        }\n        return prev;\n    }\n\n    valueStack = valueStack || [obj]; // Initialize valueStack with original data object\n    args = args || []; // args defaults to empty array\n\n    // Converted Array.reduce into while loop, still using \"prev\", \"curr\", \"idx\"\n    // as loop values\n    while (prev !== undefined && idx < tkLength){\n        curr = tk[idx];\n        newValueHere = (change && (idx === tkLastIdx));\n\n        if (typeof curr === 'string'){\n            // Cannot do \".hasOwnProperty\" here since that breaks when testing\n            // for functions defined on prototypes (e.g. [1,2,3].sort())\n            if (typeof context[curr] !== 'undefined') {\n                if (newValueHere){ context[curr] = newValue; }\n                ret = context[curr];\n            }\n            else if (curr.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (Array.isArray(curr)){\n            // call resolvePath again with base value as evaluated value so far and\n            // each element of array as the path. Concat all the results together.\n            ret = [];\n            for (i = 0; curr[i] !== undefined; i++){\n                if (newValueHere){\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        context[resolvePath(context, curr[i], newValue, args, valueStack.concat())] = newValue;\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n                else {\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n            }\n        }\n        else if (typeof curr === 'undefined' || typeof prev === 'undefined'){\n            ret = undefined;\n        }\n        else if (curr.w){\n            // this word token has modifiers, modify current context\n            if (curr.mods.parent){\n                context = valueStack[curr.mods.parent];\n                if (typeof context === 'undefined') { return undefined; }\n            }\n            if (curr.mods.root){\n                // Reset context and valueStack, start over at root in this context\n                context = valueStack[valueStack.length -1];\n                valueStack = [context];\n            }\n            if (curr.mods.placeholder){\n                if (curr.w.length === 0) { return undefined; }\n                var placeInt = Number.parseInt(curr.w) - 1;\n                if (typeof args[placeInt] === 'undefined'){ return undefined; }\n                // Force args[placeInt] to String, won't attempt to process\n                // arg of type function, array, or plain object\n                curr.w = args[placeInt].toString();\n                delete(curr.mods.placeholder); // Once value has been replaced, don't want to re-process this entry\n                delete(curr.mods.has);\n            }\n\n            // Repeat basic string property processing with word and modified context\n            if (context.hasOwnProperty(curr.w)) {\n                if (newValueHere){ context[curr.w] = newValue; }\n                ret = context[curr.w];\n            }\n            else if (typeof context === 'function'){\n                ret = curr.w;\n            }\n            else if (curr.w.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr.w, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (curr.exec === 'property'){\n            if (newValueHere){\n                context[resolvePath(context, curr, newValue, args, valueStack.concat())] = newValue;\n            }\n            ret = context[resolvePath(context, curr, newValue, args, valueStack.concat())];\n        }\n        else if (curr.exec === 'call'){\n            // TODO: handle params for function\n            var callArgs = resolvePath(context, curr, newValue, args, valueStack.concat());\n            if (callArgs === undefined){\n                ret = context.apply(valueStack[1]);\n            }\n            else if (Array.isArray(callArgs)){\n                ret = context.apply(valueStack[1], callArgs);\n            }\n            else {\n                ret = context.call(valueStack[1], callArgs);\n            }\n        }\n        valueStack.unshift(ret);\n        context = ret;\n        prev = ret;\n        idx++;\n    }\n    return context;\n};\n\nvar scanForValue = function(obj, val, savePath, path){\n    var i, len, prop, more;\n\n    path = path ? path : '';\n\n    if (obj === val){\n        return savePath(path); // true -> keep looking; false -> stop now\n    }\n    else if (Array.isArray(obj)){\n        len = obj.length;\n        for(i = 0; i < len; i++){\n            more = scanForValue(obj[i], val, savePath, path + '.' + i);\n            if (!more){ return; }\n        }\n        return true; // keep looking\n    }\n    else if (isObject(obj)) {\n        for (prop in obj){\n            if (obj.hasOwnProperty(prop)){\n                more = scanForValue(obj[prop], val, savePath, path + '.' + prop);\n                if (!more){ return; }\n            }\n        }\n        return true; // keep looking\n    }\n    // Leaf node (string, number, character, boolean, etc.), but didn't match\n    return true; // keep looking\n};\n\nexport var getTokens = function(path){\n    return {t: tokenize(path)};\n};\n\nexport var getPath = function (obj, path){\n    var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : [];\n    return resolvePath(obj, path, undefined, args);\n};\n\nexport var setPath = function(obj, path, val){\n    var args = arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : [],\n        ref = resolvePath(obj, path, val, args);\n    if (Array.isArray(ref)){\n        return ref.indexOf(undefined) === -1;\n    }\n    return typeof ref !== 'undefined';\n};\n\nexport var getPathFor = function(obj, val, oneOrMany){\n    var retVal = [];\n    var savePath = function(path){\n        retVal.push(path.substr(1));\n        if(!oneOrMany || oneOrMany === 'one'){\n            retVal = retVal[0];\n            return false;\n        }\n        return true;\n    };\n    scanForValue(obj, val, savePath);\n    return retVal[0] ? retVal : undefined;\n};\n\nexport var setOptions = function(options){\n    if (options.prefixes){\n        for (var p in options.prefixes){\n            if (options.prefixes.hasOwnProperty(p)){\n                prefixes[p] = options.prefixes[p];\n            }\n        }\n    }\n    if (options.separators){\n        for (var s in options.separators){\n            if (options.separators.hasOwnProperty(s)){\n                separators[s] = options.separators[s];\n            }\n        }\n    }\n    if (options.containers){\n        for (var c in options.containers){\n            if (options.containers.hasOwnProperty(c)){\n                containers[c] = options.containers[c];\n            }\n        }\n    }\n    if (typeof options.cache !== 'undefined'){\n        useCache = !!options.cache;\n    }\n};\n"],"names":["EMPTY_STRING","prefixes","prefixList","Object","keys","separators","separatorList","containers","containerList","wildCardMatch","template","str","pos","indexOf","parts","split","match","substr","length","specials","concat","join","replace","specialRegEx","RegExp","isObject","val","useCache","cache","tokenize","tokens","mods","strLength","word","i","opener","closer","separator","collection","depth","exec","push","has","undefined","resolvePath","obj","path","newValue","args","valueStack","change","tk","t","tkLength","tkLastIdx","prev","curr","idx","context","ret","newValueHere","prop","hasOwnProperty","Array","isArray","w","parent","root","placeholder","placeInt","Number","parseInt","toString","callArgs","apply","call","unshift","scanForValue","savePath","len","more","getTokens","getPath","arguments","prototype","slice","setPath","ref","getPathFor","oneOrMany","retVal","setOptions","options","p","s","c"],"mappings":"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","sourceRoot":"/source/"}
