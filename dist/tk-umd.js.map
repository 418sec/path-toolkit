{"version":3,"file":"tk-umd.js","sources":["tk.js"],"sourcesContent":["// Parsing, tokeninzing, etc\n'use strict';\n\nvar prefixes = {\n    '<': {\n        'exec': 'parent'\n    },\n    '~': {\n        'exec': 'root'\n    },\n    '%': {\n        'exec': 'placeholder'\n    }\n},\nprefixList = Object.keys(prefixes);\n\nvar separators = {\n    '.': {\n        'exec': 'property'\n        },\n    ',': {\n        'exec': 'collection'\n        }\n},\nseparatorList = Object.keys(separators);\n\nvar containers = {\n    // '[': {\n    //     'closer': ']',\n    //     'exec': '??'\n    //     },\n    '(': {\n        'closer': ')',\n        'exec': 'call'\n        },\n    '{': {\n        'closer': '}',\n        'exec': 'property'\n        }\n},\ncontainerList = Object.keys(containers);\n\nvar wildCardMatch = function(template, str){\n    var pos = template.indexOf('*'),\n        parts = template.split('*', 2),\n        match = true;\n    if (parts[0]){\n        match = match && str.substr(0, parts[0].length) === parts[0];\n    }\n    if (parts[1]){\n        match = match && str.substr(pos+1) === parts[1];\n    }\n    return match;\n};\nvar specials = '[\\\\' + ['*'].concat(prefixList).concat(separatorList).concat(containerList).join('\\\\').replace(/\\\\?\\./, '') + ']';\nvar specialRegEx = new RegExp(specials);\nconsole.log('Specials:', specialRegEx.toString());\nconsole.log(specialRegEx.test('abc()'));\n\nvar isObject = function(val) {\n    if (val === null) { return false;}\n    return ( (typeof val === 'function') || (typeof val === 'object') );\n};\n\nvar flatten = function(ary){\n    ary = Array.isArray(ary) ? ary : [ary];\n    return ary.reduce(function(a, b) {\n      return a.concat(b);\n    },[]);\n};\n\nvar cache = {};\n\n/*\n *  Scan input string from left to right, one character at a time. If a special character\n *  is found (one of \"separators\" or \"containers\"), either store the accumulated word as\n *  a token or else begin watching input for end of token (finding a closing character for\n *  a container or the end of a collection). If a container is found, call tokenize\n *  recursively on string within container.\n */\nvar tokenize = function (str){\n    if (cache[str]){ return cache[str]; }\n\n    var tokens = [],\n        mods = {},\n        strLength = str.length,\n        word = '',\n        substr = '',\n        i,\n        opener, closer, separator,\n        collection = [],\n        depth = 0;\n\n    // console.log('Parsing:', str);\n\n    for (i = 0; i < strLength; i++){\n        if (depth > 0){\n            // Scan for closer\n            str[i] === opener && depth++;\n            str[i] === closer.closer && depth--;\n\n            if (depth > 0){\n                substr += str[i];\n            }\n            // TODO: handle comma-separated elements when depth === 1, process as function arguments\n            else {\n                if (i+1 < strLength && separators[str[i+1]] && separators[str[i+1]].exec === 'collection'){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                else if (collection[0]){\n                    collection.push({'t':tokenize(substr), 'exec': closer.exec});\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    tokens.push({'t':tokenize(substr), 'exec': closer.exec});\n                }\n                substr = '';\n            }\n        }\n        else if (str[i] in prefixes){\n            mods.has = true;\n            if (mods[prefixes[str[i]].exec]) { mods[prefixes[str[i]].exec]++; }\n            else { mods[prefixes[str[i]].exec] = 1; }\n        }\n        else if (str[i] in separators){\n            separator = separators[str[i]];\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (separator.exec === 'property'){\n                // word is a plain property or end of collection\n                if (collection[0] !== undefined){\n                    // we are gathering a collection, so add last word to collection and then store\n                    word && collection.push(word);\n                    tokens.push(collection);\n                    collection = [];\n                }\n                else {\n                    // word is a plain property\n                    word && tokens.push(word);\n                }\n            }\n            else if (separator.exec === 'collection'){\n                // word is a collection\n                word && collection.push(word);\n            }\n            word = '';\n        }\n        else if (closer = containers[str[i]]){\n            // found opener, initiate scan for closer\n            if (word && mods.has){\n                word = {'w': word, 'mods': mods};\n                mods = {};\n            }\n            if (collection[0] !== undefined){\n                // we are gathering a collection, so add last word to collection and then store\n                word && collection.push(word);\n            }\n            else {\n                // word is a plain property\n                word && tokens.push(word);\n            }\n            word = '';\n            opener = str[i];\n            depth++;\n        }\n        else {\n            // still accumulating property name\n            word += str[i];\n        }\n    }\n    // add trailing word to tokens, if present\n    if (word && mods.has){\n        word = {'w': word, 'mods': mods};\n        mods = {};\n    }\n    if (collection[0] !== undefined){\n        // we are gathering a collection, so add last word to collection and then store\n        word && collection.push(word);\n        tokens.push(collection);\n    }\n    else {\n        // word is a plain property\n        word && tokens.push(word);\n    }\n\n    // depth != 0 means mismatched containers\n    if (depth !== 0){ return undefined; }\n\n    cache[str] = tokens;\n    return tokens;\n};\n\n// var getContext = function getContext(context, valueStack, word){\n// \tif (!prefixes[word[0]]){\n// \t\treturn context;\n// \t}\n// \tvar counter = 0,\n// \t\tprefix,\n// \t\tnewContext;\n// \twhile (prefix = prefixes[word[counter]]){\n// \t\tif (prefix.exec === 'parent'){\n// \t\t\tnewContext = valueStack[counter + 1];\n// \t\t}\n// \t\tcounter++;\n// \t}\n// \treturn newContext;\n// };\n\n// var cleanWord = function cleanWord(word){\n// \tif(!prefixes[word[0]]){\n// \t\treturn word;\n// \t}\n// \tvar len = word.length;\n// \tfor (var i = 1; i < len; i++){\n// \t\tif (!prefixes[word[i]]){\n// \t\t\treturn word.substr(i);\n// \t\t}\n// \t}\n// \treturn '';\n// }\n\nvar resolvePath = function (obj, path, newValue, args, valueStack){\n    if (typeof path === 'string' && typeof newValue === 'undefined' && !path.match(specialRegEx)){\n        var ary = path.split('.');\n        var len = ary.length;\n        var returnVal = obj;\n        var i = 0;\n        while (returnVal !== undefined && i < len){\n            if (i.length < 0){ returnVal = undefined; }\n            returnVal = returnVal[ary[i]];\n            i++;\n        }\n        return returnVal;\n    }\n\n    valueStack = valueStack || [obj]; // Initialize valueStack with original data object\n    args = args || []; // args defaults to empty array\n\n    var change = newValue !== undefined,\n        val,\n        tk,\n        i,\n        root = valueStack[valueStack.length -1]; // Root is an alias for original data object\n\n    tk = typeof path === 'string' ? tokenize(path) : path.t ? path.t : [path];\n\n    return tk.length === 0 ? undefined : tk.reduce(function(prev, curr, idx){\n        var context = valueStack[0],\n            ret,\n            lastToken = (idx === (tk.length - 1)),\n            newValueHere = (change && lastToken);\n        if (typeof curr === 'string'){\n            // Cannot do \".hasOwnProperty\" here since that breaks when testing\n            // for functions defined on prototypes (e.g. [1,2,3].sort())\n            if (typeof context[curr] !== 'undefined') {\n                if (newValueHere){ context[curr] = newValue; }\n                ret = context[curr];\n            }\n            else if (curr.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (Array.isArray(curr)){\n            // call resolvePath again with base value as evaluated value so far and\n            // each element of array as the path. Concat all the results together.\n            ret = [];\n            for (i = 0; curr[i] !== undefined; i++){\n                if (newValueHere){\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        context[resolvePath(context, curr[i], newValue, args, valueStack.concat())] = newValue;\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n                else {\n                    if (curr[i].t && curr[i].exec === 'property'){\n                        ret = ret.concat(context[resolvePath(context, curr[i], newValue, args, valueStack.concat())]);\n                    } else {\n                        ret = ret.concat(resolvePath(context, curr[i], newValue, args, valueStack.concat()));\n                    }\n                }\n            }\n        }\n        else if (typeof curr === 'undefined' || typeof prev === 'undefined'){\n            ret = undefined;\n        }\n        else if (curr.w){\n            // this word token has modifiers, modify current context\n            if (curr.mods.parent){\n                context = valueStack[curr.mods.parent];\n                if (typeof context === 'undefined') { return undefined; }\n            }\n            if (curr.mods.root){\n                // Reset context and valueStack, start over at root in this context\n                context = root;\n                valueStack = [root];\n            }\n            if (curr.mods.placeholder){\n                if (curr.w.length === 0) { return undefined; }\n                var placeInt = Number.parseInt(curr.w) - 1;\n                if (typeof args[placeInt] === 'undefined'){ return undefined; }\n                // Force args[placeInt] to String, won't attempt to process\n                // arg of type function, array, or plain object\n                curr.w = args[placeInt].toString();\n                delete(curr.mods.placeholder); // Once value has been replaced, don't want to re-process this entry\n                delete(curr.mods.has);\n            }\n\n            // Repeat basic string property processing with word and modified context\n            if (context.hasOwnProperty(curr.w)) {\n                if (newValueHere){ context[curr.w] = newValue; }\n                ret = context[curr.w];\n            }\n            else if (typeof context === 'function'){\n                ret = curr.w;\n            }\n            else if (curr.w.indexOf('*') >-1){\n                ret = [];\n                for (var prop in context){\n                    if (context.hasOwnProperty(prop) && wildCardMatch(curr.w, prop)){\n                        if (newValueHere){ context[prop] = newValue; }\n                        ret.push(context[prop]);\n                    }\n                }\n            }\n            else { return undefined; }\n        }\n        else if (curr.exec === 'property'){\n            if (newValueHere){\n                context[resolvePath(context, curr, newValue, args, valueStack.concat())] = newValue;\n            }\n            ret = context[resolvePath(context, curr, newValue, args, valueStack.concat())];\n        }\n        else if (curr.exec === 'call'){\n            // TODO: handle params for function\n            var callArgs = resolvePath(context, curr, newValue, args, valueStack.concat());\n            if (callArgs === undefined){\n                ret = context.apply(valueStack[1]);\n            }\n            else if (Array.isArray(callArgs)){\n                ret = context.apply(valueStack[1], callArgs);\n            }\n            else {\n                ret = context.call(valueStack[1], callArgs);\n            }\n        }\n        valueStack.unshift(ret);\n        return ret;\n    }, obj);\n};\n\nvar scanForValue = function(obj, val, savePath, path){\n    var i, len, prop, more;\n\n    path = path ? path : '';\n\n    if (obj === val){\n        return savePath(path); // true -> keep looking; false -> stop now\n    }\n    else if (Array.isArray(obj)){\n        len = obj.length;\n        for(i = 0; i < len; i++){\n            more = scanForValue(obj[i], val, savePath, path + '.' + i);\n            if (!more){ return; }\n        }\n        return true; // keep looking\n    }\n    else if (isObject(obj)) {\n        for (prop in obj){\n            if (obj.hasOwnProperty(prop)){\n                more = scanForValue(obj[prop], val, savePath, path + '.' + prop);\n                if (!more){ return; }\n            }\n        }\n        return true; // keep looking\n    }\n    // Leaf node (string, number, character, boolean, etc.), but didn't match\n    return true; // keep looking\n};\n\nexport var getTokens = function(path){\n    return {t: tokenize(path)};\n};\n\nexport var getPath = function (obj, path){\n    var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : [];\n    return resolvePath(obj, path, undefined, args);\n};\n\nexport var setPath = function(obj, path, val){\n    var args = arguments.length > 3 ? Array.prototype.slice.call(arguments, 3) : [],\n        ref = resolvePath(obj, path, val, args);\n    if (Array.isArray(ref)){\n        return ref.indexOf(undefined) === -1;\n    }\n    return typeof ref !== 'undefined';\n};\n\nexport var getPathFor = function(obj, val, oneOrMany){\n    var retVal = [];\n    var savePath = function(path){\n        retVal.push(path.substr(1));\n        if(!oneOrMany || oneOrMany === 'one'){\n            retVal = retVal[0];\n            return false;\n        }\n        return true;\n    };\n    scanForValue(obj, val, savePath);\n    return retVal[0] ? retVal : undefined;\n};\n\n// export var setOptions = function(options){\n//     if (options.prefixes){\n//         for (var p in options.prefixes){\n//             if (options.prefixes.hasOwnProperty(p)){\n//                 prefixes[p] = options.prefixes[p];\n//             }\n//         }\n//     }\n//     if (options.separators){\n//         for (var s in options.separators){\n//             if (options.separators.hasOwnProperty(s)){\n//                 separators[s] = options.separators[s];\n//             }\n//         }\n//     }\n//     if (options.containers){\n//         for (var c in options.containers){\n//             if (options.containers.hasOwnProperty(c)){\n//                 containers[c] = options.containers[c];\n//             }\n//         }\n//     }\n// };\n"],"names":["prefixes","prefixList","Object","keys","separators","separatorList","containers","containerList","wildCardMatch","template","str","pos","indexOf","parts","split","match","substr","length","specials","concat","join","replace","specialRegEx","RegExp","console","log","toString","test","isObject","val","cache","tokenize","tokens","mods","strLength","word","i","opener","closer","separator","collection","depth","exec","push","has","undefined","resolvePath","obj","path","newValue","args","valueStack","ary","len","returnVal","change","tk","root","t","reduce","prev","curr","idx","context","ret","lastToken","newValueHere","prop","hasOwnProperty","Array","isArray","w","parent","placeholder","placeInt","Number","parseInt","callArgs","apply","call","unshift","scanForValue","savePath","more","getTokens","getPath","arguments","prototype","slice","setPath","ref","getPathFor","oneOrMany","retVal"],"mappings":"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","sourceRoot":"/source/"}