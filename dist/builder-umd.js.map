{"version":3,"file":"builder-umd.js","sources":["null.js","lexer/grammar.js","builder/syntax.js","builder/node.js","builder.js"],"sourcesContent":["'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nfunction Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;\n\nexport { Null as default };","'use strict';\n\nimport Null from '../null';\n\nvar Grammar = new Null();\n\nGrammar.Identifier  = 'Identifier';\nGrammar.Literal     = 'Literal';\nGrammar.Punctuator  = 'Punctuator';\n\nexport { Grammar as default };","'use strict';\n\nimport Null from '../null';\n\nvar Syntax = new Null();\n\nSyntax.ArrayExpression      = 'ArrayExpression';\nSyntax.CallExpression       = 'CallExpression';\nSyntax.ExpressionStatement  = 'ExpressionStatement';\nSyntax.Identifier           = 'Identifier';\nSyntax.Literal              = 'Literal';\nSyntax.MemberExpression     = 'MemberExpression';\nSyntax.Program              = 'Program';\nSyntax.SequenceExpression   = 'SequenceExpression';\n\nexport { Syntax as default };","'use strict';\n\nimport Null from '../null';\nimport Syntax from './syntax';\n\nvar nodeId = 0,\n    literalTypes = 'boolean number string'.split( ' ' );\n\n/**\n * @typedef {external:string} Builder~NodeType\n */\n\n/**\n * @class Builder~Node\n * @extends Null\n * @param {Builder~NodeType} type A node type\n */\nfunction Node( type ){\n    \n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    /**\n     * @member {external:number} Builder~Node#id\n     */\n    this.id = ++nodeId;\n    /**\n     * @member {Builder~NodeType} Builder~Node#type\n     */\n    this.type = type;\n}\n\nNode.prototype = new Null();\n\nNode.prototype.constructor = Node;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the node\n */\nNode.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.type = this.type;\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the node\n */\nNode.prototype.toString = function(){\n    return String( this.type );\n};\n\nNode.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Node as default };\n\n/**\n * @class Builder~Expression\n * @extends Builder~Node\n * @param {Builder~NodeType} expressionType A node type\n */\nfunction Expression( expressionType ){\n    Node.call( this, expressionType );\n}\n\nExpression.prototype = Object.create( Node.prototype );\n\nExpression.prototype.constructor = Expression;\n\n/**\n * @class Builder~MemberExpression\n * @extends Builder~Expression\n * @param {Builder~Expression} object\n * @param {Builder~Expression|Builder~Identifier} property\n * @param {external:boolean} computed=false\n */\nfunction MemberExpression( object, property, computed ){\n    Expression.call( this, Syntax.MemberExpression );\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.object = object;\n    /**\n     * @member {Builder~Expression|Builder~Identifier}\n     */\n    this.property = property;\n    /**\n     * @member {external:boolean}\n     */\n    this.computed = computed || false;\n}\n\nMemberExpression.prototype = Object.create( Expression.prototype );\n\nMemberExpression.prototype.constructor = MemberExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the member expression\n */\nMemberExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.object   = this.object.toJSON();\n    json.property = this.property.toJSON();\n    json.computed = this.computed;\n    \n    return json;\n};\n\n/**\n * @class Builder~Program\n * @extends Builder~Node\n * @param {external:Array<Builder~Statement>} body\n */\nexport function Program( body ){\n    Node.call( this, Syntax.Program );\n    \n    if( !Array.isArray( body ) ){\n        throw new TypeError( 'body must be an array' );\n    }\n    \n    /**\n     * @member {external:Array<Builder~Statement>}\n     */\n    this.body = body || [];\n}\n\nProgram.prototype = Object.create( Node.prototype );\n\nProgram.prototype.constructor = Program;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the program\n */\nProgram.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.body = this.body.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\n/**\n * @class Builder~Statement\n * @extends Builder~Node\n * @param {Builder~NodeType} statementType A node type\n */\nfunction Statement( statementType ){\n    Node.call( this, statementType );\n}\n\nStatement.prototype = Object.create( Node.prototype );\n\nStatement.prototype.constructor = Statement;\n\n/**\n * @class Builder~ArrayExpression\n * @extends Builder~Expression\n * @param {external:Array<Builder~Expression>} elements A list of expressions\n */\nexport function ArrayExpression( elements ){\n    Expression.call( this, Syntax.ArrayExpression );\n    \n    if( !( Array.isArray( elements ) ) ){\n        throw new TypeError( 'elements must be a list of expressions' );\n    }\n    \n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.elements = elements;\n}\n\nArrayExpression.prototype = Object.create( Expression.prototype );\n\nArrayExpression.prototype.constructor = ArrayExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the array expression\n */\nArrayExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.elements = this.elements.map( function( element ){\n        return element.toJSON();\n    } );\n    \n    return json;\n};\n\n/**\n * @class Builder~CallExpression\n * @extends Builder~Expression\n * @param {Builder~Expression} callee\n * @param {Array<Builder~Expression>} args\n */\nexport function CallExpression( callee, args ){\n    Expression.call( this, Syntax.CallExpression );\n    \n    if( !Array.isArray( args ) ){\n        throw new TypeError( 'arguments must be an array' );\n    }\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.callee = callee;\n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.arguments = args;\n}\n\nCallExpression.prototype = Object.create( Expression.prototype );\n\nCallExpression.prototype.constructor = CallExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the call expression\n */\nCallExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.callee    = this.callee.toJSON();\n    json.arguments = this.arguments.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\nexport function ComputedMemberExpression( object, property ){\n    if( !( property instanceof Expression ) ){\n        throw new TypeError( 'property must be an expression when computed is true' );\n    }\n        \n    MemberExpression.call( this, object, property, true );\n}\n\nComputedMemberExpression.prototype = Object.create( MemberExpression.prototype );\n\nComputedMemberExpression.prototype.constructor = ComputedMemberExpression;\n\n/**\n * @class Builder~ExpressionStatement\n * @extends Builder~Statement\n */\nexport function ExpressionStatement( expression ){\n    Statement.call( this, Syntax.ExpressionStatement );\n    \n    if( !( expression instanceof Expression ) ){\n        throw new TypeError( 'argument must be an expression' );\n    }\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.expression = expression;\n}\n\nExpressionStatement.prototype = Object.create( Statement.prototype );\n\nExpressionStatement.prototype.constructor = ExpressionStatement;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the expression statement\n */\nExpressionStatement.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expression = this.expression.toJSON();\n    \n    return json;\n};\n\n/**\n * @class Builder~Identifier\n * @extends Builder~Expression\n * @param {external:string} name The name of the identifier\n */\nexport function Identifier( name ){\n    Expression.call( this, Syntax.Identifier );\n    \n    if( typeof name !== 'string' ){\n        throw new TypeError( 'name must be a string' );\n    }\n    \n    /**\n     * @member {external:string}\n     */\n    this.name = name;\n}\n\nIdentifier.prototype = Object.create( Expression.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the identifier\n */\nIdentifier.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.name = this.name;\n    \n    return json;\n};\n\n/**\n * @class Builder~Literal\n * @extends Builder~Expression\n * @param {external:string|external:number} value The value of the literal\n */\nexport function Literal( value, raw ){\n    Expression.call( this, Syntax.Literal );\n    \n    if( literalTypes.indexOf( typeof value ) === -1 ){\n        throw new TypeError( 'value must be a boolean, number, or string' );\n    }\n    \n    /**\n     * @member {external:string}\n     */\n    this.raw = raw;\n    \n    /**\n     * @member {external:string|external:number}\n     */\n    this.value = value;\n}\n\nLiteral.prototype = Object.create( Expression.prototype );\n\nLiteral.prototype.constructor = Literal;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the literal\n */\nLiteral.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};\n\n/**\n * @class Builder~SequenceExpression\n * @extends Builder~Expression\n * @param {Array<Builder~Expression>} expressions The expressions in the sequence\n */\nexport function SequenceExpression( expressions ){\n    Expression.call( this, Syntax.SequenceExpression );\n    \n    if( !( Array.isArray( expressions ) ) ){\n        throw new TypeError( 'expressions must be a list of expressions' );\n    }\n    \n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.expressions = expressions;\n}\n\nSequenceExpression.prototype = Object.create( Expression.prototype );\n\nSequenceExpression.prototype.constructor = SequenceExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the sequence expression\n */\nSequenceExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expressions = this.expressions.map( function( expression ){\n        return expression.toJSON();\n    } );\n    \n    return json;\n};\n\nexport function StaticMemberExpression( object, property ){\n    if( !( property instanceof Identifier ) ){\n        throw new TypeError( 'property must be an identifier when computed is false' );\n    }\n        \n    MemberExpression.call( this, object, property, false );\n}\n\nStaticMemberExpression.prototype = Object.create( MemberExpression.prototype );\n\nStaticMemberExpression.prototype.constructor = StaticMemberExpression;","'use strict';\n\nimport Null from './null';\nimport Grammar from './lexer/grammar';\nimport { ArrayExpression, CallExpression, ComputedMemberExpression, ExpressionStatement, Identifier, Literal, Program, SequenceExpression, StaticMemberExpression } from './builder/node';\n\n/**\n * @class Builder\n * @extends Null\n * @param {Lexer} lexer\n */\nfunction Builder( lexer ){\n    this.lexer = lexer;\n}\n\nBuilder.prototype = new Null();\n\nBuilder.prototype.constructor = Builder;\n\nBuilder.prototype.arrayExpression = function( list ){\n    var end = ( list.length ? list[ list.length - 1 ].range[ 1 ] : 1 ) + 1,\n        node;\n        \n    this.consume( '[' );\n    \n    node = new ArrayExpression( list );\n    node.range = [ this.column, end ];\n    \n    return node;\n};\n\n/**\n * @function\n * @param {external:string|Array<Builder~Token>} input\n * @returns {Program} The built abstract syntax tree\n */\nBuilder.prototype.build = function( input ){\n    if( typeof input === 'string' ){\n        /**\n         * @member {external:string}\n         */\n        this.text = input;\n        \n        if( typeof this.lexer === 'undefined' ){\n            this.throwError( 'lexer is not defined' );\n        }\n        \n        /**\n         * @member {external:Array<Token>}\n         */\n        this.tokens = this.lexer.lex( input );\n    } else if( Array.isArray( input ) ){\n        this.tokens = input.slice();\n        this.text = input.join( '' );\n    } else {\n        this.throwError( 'invalid input' );\n    }\n    \n    //console.log( 'BUILD' );\n    //console.log( '- ', this.text.length, 'CHARS', this.text );\n    //console.log( '- ', this.tokens.length, 'TOKENS', this.tokens );\n    \n    this.column = this.text.length;\n    \n    var program = this.program();\n    \n    if( this.tokens.length ){\n        this.throwError( 'Unexpected token ' + this.tokens[ 0 ] + ' remaining' );\n    }\n    \n    return program;\n};\n\n/**\n * @function\n * @returns {CallExpression} The call expression node\n */\nBuilder.prototype.callExpression = function(){\n    var end = this.column + 1,\n        args = this.list( '(' ),\n        callee, node, start;\n        \n    this.consume( '(' );\n    \n    callee = this.expression();\n    \n    start = this.column;\n    \n    //console.log( 'CALL EXPRESSION' );\n    //console.log( '- CALLEE', callee );\n    //console.log( '- ARGUMENTS', args, args.length );\n    \n    node = new CallExpression( callee, args );\n    node.range = [ start, end ];\n    \n    return node;\n};\n\n/**\n * Removes the next token in the token list. If a comparison is provided, the token will only be returned if the value matches. Otherwise an error is thrown.\n * @function\n * @param {external:string} [expected] An expected comparison value\n * @returns {Token} The next token in the list\n * @throws {SyntaxError} If token did not exist\n */\nBuilder.prototype.consume = function( expected ){\n    if( !this.tokens.length ){\n        this.throwError( 'Unexpected end of expression' );\n    }\n    \n    var token = this.expect( expected );\n    \n    if( !token ){\n        this.throwError( 'Unexpected token ' + token.value + ' consumed' );\n    }\n    \n    return token;\n};\n\n/**\n * Removes the next token in the token list. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Token} The next token in the list or `undefined` if it did not exist\n */\nBuilder.prototype.expect = function( first, second, third, fourth ){\n    var token = this.peek( first, second, third, fourth );\n    \n    if( token ){\n        this.tokens.pop();\n        this.column -= token.length;\n        return token;\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Expression} An expression node\n */\nBuilder.prototype.expression = function(){\n    var expression = null,\n        list, next, token;\n    \n    if( next = this.peek() ){\n        if( this.expect( ']' ) ){\n            list = this.list( '[' );\n            if( this.tokens.length === 1 ){\n                expression = this.arrayExpression( list );\n            } else if( list.length > 1 ){\n                expression = this.sequenceExpression( list );\n            } else {\n                expression = list[ 0 ];\n            }\n        } else if( next.type === Grammar.Identifier ){\n            expression = this.identifier();\n            next = this.peek();\n            \n            // Implied member expression\n            if( next && next.type === Grammar.Punctuator ){\n                if( next.value === ')' || next.value === ']' ){\n                    expression = this.memberExpression( expression, false );\n                }\n            }\n        } else if( next.type === Grammar.Literal ){\n            expression = this.literal();\n        }\n        \n        while( ( token = this.expect( ')', '[', '.' ) ) ){\n            if( token.value === ')' ){\n                expression = this.callExpression();\n            } else if( token.value === '[' ){\n                expression = this.memberExpression( expression, true );\n            } else if( token.value === '.' ){\n                expression = this.memberExpression( expression, false );\n            } else {\n                this.throwError( 'Unexpected token ' + token );\n            }\n        }\n    }\n    \n    return expression;\n};\n\n/**\n * @function\n * @returns {ExpressionStatement} An expression statement\n */\nBuilder.prototype.expressionStatement = function(){\n    var end = this.column,\n        node = this.expression(),\n        start = this.column,\n        expressionStatement = new ExpressionStatement( node );\n    \n    expressionStatement.range = [ start, end ];\n    \n    return expressionStatement;\n};\n\n/**\n * @function\n * @returns {Identifier} An identifier\n * @throws {SyntaxError} If the token is not an identifier\n */\nBuilder.prototype.identifier = function(){\n    var end = this.column,\n        token = this.consume(),\n        start = this.column,\n        node;\n    \n    if( !( token.type === Grammar.Identifier ) ){\n        this.throwError( 'Identifier expected' );\n    }\n    \n    node = new Identifier( token.value );\n    node.range = [ start, end ];\n    \n    return node;\n};\n\n/**\n * @function\n * @returns {Literal} The literal node\n */\nBuilder.prototype.literal = function(){\n    var end = this.column,\n        token = this.consume(),\n        start = this.column,\n        node, raw, value;\n    \n    if( !( token.type === Grammar.Literal ) ){\n        this.throwError( 'Literal expected' );\n    }\n    \n    raw = token.value;\n\n    value = raw[ 0 ] === '\"' || raw[ 0 ] === \"'\" ?\n        // String Literal\n        raw.substring( 1, raw.length - 1 ) :\n        // Numeric Literal\n        parseFloat( raw );\n    \n    node = new Literal( value, raw );\n    node.range = [ start, end ];\n    \n    return node;\n};\n\n/**\n * @function\n * @param {external:string} terminator\n * @returns {external:Array<Literal>} The list of literals\n */\nBuilder.prototype.list = function( terminator ){\n    var list = [];\n    \n    if( this.peek().value !== terminator ){\n        do {\n            list.unshift( this.literal() );\n        } while( this.expect( ',' ) );\n    }\n    \n    return list;\n};\n\n/**\n * @function\n * @param {Expression} property The expression assigned to the property of the member expression\n * @param {external:boolean} computed Whether or not the member expression is computed\n * @returns {MemberExpression} The member expression\n */\nBuilder.prototype.memberExpression = function( property, computed ){\n    var end = property.range[ 1 ] + ( computed ? 1 : 0 ),\n        object = this.expression(),\n        start = this.column,\n        node;\n    \n    //console.log( 'MEMBER EXPRESSION' );\n    //console.log( '- OBJECT', object );\n    //console.log( '- PROPERTY', property );\n    //console.log( '- COMPUTED', computed );\n    \n    node = computed ?\n        new ComputedMemberExpression( object, property ) :\n        new StaticMemberExpression( object, property );\n    \n    node.range = [ start, end ];\n    \n    return node;\n};\n\n/**\n * Provides the next token in the token list _without removing it_. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Lexer~Token} The next token in the list or `undefined` if it did not exist\n */\nBuilder.prototype.peek = function( first, second, third, fourth ){\n    return this.tokens.length ?\n        this.peekAt( 0, first, second, third, fourth ) :\n        undefined;\n};\n\n/**\n * Provides the token at the requested position _without removing it_ from the token list. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:number} position The position where the token will be peeked\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Lexer~Token} The token at the requested position or `undefined` if it did not exist\n */\nBuilder.prototype.peekAt = function( position, first, second, third, fourth ){\n    var index, length, token, value;\n    \n    if( typeof position === 'number' && position > -1 ){\n        length = this.tokens.length;\n        index = length - position - 1;\n        \n        if( index > -1 && index < length ){\n            token = this.tokens[ index ];\n            value = token.value;\n            \n            if( value === first || value === second || value === third || value === fourth || ( !first && !second && !third && !fourth ) ){\n                return token;\n            }\n        }\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Program} A program node\n */\nBuilder.prototype.program = function(){\n    var end = this.column,\n        body = [],\n        node;\n    \n    while( true ){\n        if( this.tokens.length ){\n            body.push( this.expressionStatement() );\n        } else {\n            node = new Program( body );\n            node.range = [ this.column, end ];\n            return node;\n        }\n    }\n};\n\nBuilder.prototype.sequenceExpression = function( list ){\n    var end = list[ list.length - 1 ].range[ 1 ],\n        node = new SequenceExpression( list );\n    \n    node.range = [ this.column, end ];\n    \n    return node;\n};\n\n/**\n * @function\n * @param {external:string} message The error message\n * @throws {external:SyntaxError} When it executes\n */\nBuilder.prototype.throwError = function( message ){\n    throw new SyntaxError( message );\n};\n\nexport { Builder as default };"],"names":[],"mappings":"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","sourceRoot":"/source/"}