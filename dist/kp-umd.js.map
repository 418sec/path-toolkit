{"version":3,"file":"kp-umd.js","sources":["null.js","lexer/token.js","lexer.js","builder/position.js","builder/sourceLocation.js","builder/node.js","builder.js","forEach.js","interpreter.js","keypath.js","kp.js"],"sourcesContent":["'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nfunction Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;\n\nexport { Null as default };","'use strict';\n\nimport Null from '../null';\n\nvar tokenId = 0;\n\n/**\n * @class Lexer~Token\n * @extends Null\n * @param {external:string} type The type of the token\n * @param {external:string} value The value of the token\n * @throws {external:TypeError} If `type` is not a string\n * @throws {external:TypeError} If `value` is not a string\n */\nfunction Token( type, value ){\n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    if( typeof value !== 'string' ){\n        throw new TypeError( 'value must be a string' );\n    }\n    \n    /**\n     * @member {external:number} Lexer~Token#id\n     */\n    this.id = ++tokenId;\n    /**\n     * @member {external:string} Lexer~Token#type\n     */\n    this.type = type;\n    /**\n     * @member {external:string} Lexer~Token#value\n     */\n    this.value = value;\n    /**\n     * The length of the token value\n     * @member {external:number} Lexer~Token#length\n     */\n    this.length = value.length;\n}\n\nToken.prototype = new Null();\n\nToken.prototype.constructor = Token;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the token\n */\nToken.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.type = this.type;\n    json.value = this.value;\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the token\n */\nToken.prototype.toString = function(){\n    return String( this.value );\n};\n\nexport { Token as default };\n\n/**\n * @class Lexer~Identifier\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Identifier( value ){\n    Token.call( this, 'identifier', value );\n}\n\nIdentifier.prototype = Object.create( Token.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\n/**\n * @class Lexer~Literal\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Literal( value ){\n    Token.call( this, 'literal', value );\n}\n\nLiteral.prototype = Object.create( Token.prototype );\n\nLiteral.prototype.constructor = Literal;\n\n/**\n * @class Lexer~Punctuator\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Punctuator( value ){\n    Token.call( this, 'punctuator', value );\n}\n\nPunctuator.prototype = Object.create( Token.prototype );\n\nPunctuator.prototype.constructor = Punctuator;","'use strict';\n\nimport Null from './null';\nimport { Identifier, Literal, Punctuator } from './lexer/token';\n\n/**\n * @function Lexer~isIdentifier\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is an identifier character\n */\nfunction isIdentifier( char ){\n    return 'a' <= char && char <= 'z' || 'A' <= char && char <= 'Z' || '_' === char || char === '$';\n}\n\n/**\n * @function Lexer~isNumeric\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a numeric character\n */\nfunction isNumeric( char ){\n    return '0' <= char && char <= '9';\n}\n\n/**\n * @function Lexer~isPunctuator\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a punctuator character\n */\nfunction isPunctuator( char ){\n    return char === '.' || char === '(' || char === ')' || char === '[' || char === ']' || char === ',' || char === '%';\n}\n\n/**\n * @function Lexer~isQuote\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a quote character\n */\nfunction isQuote( char ){\n    return char === '\"' || char === \"'\";\n}\n\n/**\n * @function Lexer~isWhitespace\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a whitespace character\n */\nfunction isWhitespace( char ){\n    return char === ' ' || char === '\\r' || char === '\\t' || char === '\\n' || char === '\\v' || char === '\\u00A0';\n}\n\n/**\n * @class Lexer~LexerError\n * @extends external:SyntaxError\n * @param {external:string} message The error message\n */\nfunction LexerError( message ){\n    SyntaxError.call( this, message );    \n}\n\nLexerError.prototype = Object.create( SyntaxError.prototype );\n\n/**\n * @class Lexer\n * @extends Null\n */\nfunction Lexer(){\n    this.buffer = '';\n}\n\nLexer.prototype = new Null();\n\nLexer.prototype.constructor = Lexer;\n\n/**\n * @function\n * @param {external:string} text\n */\nLexer.prototype.lex = function( text ){\n    /**\n     * @member {external:string}\n     * @default ''\n     */\n    this.buffer = text;\n    /**\n     * @member {external:number}\n     */\n    this.index = 0;\n    /**\n     * @member {Array<Lexer~Token>}\n     */\n    this.tokens = [];\n    \n    var length = this.buffer.length,\n        word = '',\n        char, quote;\n    \n    while( this.index < length ){\n        char = this.buffer[ this.index ];\n        \n        // Identifier\n        if( isIdentifier( char ) ){\n            word = this.read( function( char ){\n                return !isIdentifier( char ) && !isNumeric( char );\n            } );\n            \n            this.tokens.push( new Identifier( word ) );\n        \n        // Punctuator\n        } else if( isPunctuator( char ) ){\n            this.tokens.push( new Punctuator( char ) );\n            this.index++;\n        \n        // Quoted String\n        } else if( isQuote( char ) ){\n            quote = char;\n            \n            this.index++;\n            \n            word = this.read( function( char ){\n                return char === quote;\n            } );\n            \n            this.tokens.push( new Literal( quote + word + quote ) );\n            \n            this.index++;\n        \n        // Numeric\n        } else if( isNumeric( char ) ){\n            word = this.read( function( char ){\n                return !isNumeric( char );\n            } );\n            \n            this.tokens.push( new Literal( word ) );\n        \n        // Whitespace\n        } else if( isWhitespace( char ) ){\n            this.index++;\n        \n        // Error\n        } else {\n            this.throwError( '\"' + char + '\" is an invalid character' );\n        }\n        \n        word = '';\n    }\n    \n    return this.tokens;\n};\n\n/**\n * @function\n * @param {external:function} until A condition that when met will stop the reading of the buffer\n * @returns {external:string} The portion of the buffer read\n */\nLexer.prototype.read = function( until ){\n    var start = this.index,\n        char;\n    \n    while( this.index < this.buffer.length ){\n        char = this.buffer[ this.index ];\n        \n        if( until( char ) ){\n            break;\n        }\n        \n        this.index++;\n    }\n    \n    return this.buffer.slice( start, this.index );\n};\n\n/**\n * @function\n * @throws {Lexer~LexerError} When it executes\n */\nLexer.prototype.throwError = function( message ){\n    throw new LexerError( message );\n};\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the lexer\n */\nLexer.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.buffer = this.buffer;\n    json.tokens = this.tokens.map( function( token ){\n        return token.toJSON();\n    } );\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the lexer\n */\nLexer.prototype.toString = function(){\n    return this.buffer;\n};\n\nexport { Lexer as default };","'use strict';\n\nimport Null from '../null';\n\nfunction Position( line, column ){\n    if( typeof line !== 'number' || line < 1 ){\n        throw new TypeError( 'line must be a positive number' );\n    }\n    \n    if( typeof column !== 'number' || column < 0 ){\n        throw new TypeError( 'column must be a positive number or 0' );\n    }\n    \n    this.line = line;\n    this.column = column;\n}\n\nPosition.prototype = new Null();\n\nPosition.prototype.constructor = Position;\n\nPosition.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.line = this.line;\n    json.column = this.column;\n    \n    return json;\n};\n\nPosition.prototype.toString = function(){\n    return this.line + ',' + this.column;\n};\n\nexport { Position as default };","'use strict';\n\nimport Null from '../null';\nimport Position from './position';\n\nfunction SourceLocation( start, end ){\n    if( !( start instanceof Position ) ){\n        throw new TypeError( 'start must be a position' );\n    }\n    \n    if( !( end instanceof Position ) ){\n        throw new TypeError( 'end must be a position' );\n    }\n    \n    this.source = null;\n    this.start = start;\n    this.end = end;\n}\n\nSourceLocation.prototype = new Null();\n\nSourceLocation.prototype.constructor = SourceLocation;\n\nSourceLocation.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.start = this.start.toJSON();\n    json.end = this.end.toJSON();\n    \n    return json;\n};\n\nSourceLocation.prototype.toString = function(){\n    return this.start.toString() + ':' + this.end.toString();\n};\n\nexport { SourceLocation as default };","'use strict';\n\nimport Null from '../null';\nimport Position from './position';\nimport SourceLocation from './sourceLocation';\n\nvar nodeId = 0;\n\n/**\n * @typedef {external:string} Builder~NodeType\n */\n\n/**\n * @class Builder~Node\n * @extends Null\n * @param {Builder~NodeType} type A node type\n */\nfunction Node( type, location ){\n    \n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    if( arguments.length > 1 && !( location instanceof SourceLocation ) ){\n        throw new TypeError( 'location must be an instance of SourceLocation' );\n    }\n    \n    /**\n     * @member {external:number} Builder~Node#id\n     */\n    this.id = ++nodeId;\n    /**\n     * @member {Builder~NodeType} Builder~Node#type\n     */\n    this.type = type;\n    \n    this.loc = location || null;\n}\n\nNode.prototype = new Null();\n\nNode.prototype.constructor = Node;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the node\n */\nNode.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.loc = this.loc.toJSON();\n    json.type = this.type;\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the node\n */\nNode.prototype.toString = function(){\n    return String( this.type );\n};\n\nNode.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Node as default };\n\n/**\n * @class Builder~Statement\n * @extends Builder~Node\n * @param {Builder~NodeType} statementType A node type\n */\nfunction Statement( statementType, location ){\n    Node.call( this, statementType, location );\n}\n\nStatement.prototype = Object.create( Node.prototype );\n\nStatement.prototype.constructor = Statement;\n\n/**\n * @class Builder~Expression\n * @extends Builder~Node\n * @param {Builder~NodeType} expressionType A node type\n */\nfunction Expression( expressionType, location ){\n    Node.call( this, expressionType, location );\n}\n\nExpression.prototype = Object.create( Node.prototype );\n\nExpression.prototype.constructor = Expression;\n\n/**\n * @class Builder~Program\n * @extends Builder~Node\n * @param {external:Array<Builder~Statement>} body\n */\nexport function Program( body ){\n    var start = body.length ?\n            body[ 0 ].loc.start :\n            new Position( 1, 0 ),\n        end = body.length ?\n            body[ body.length - 1 ].loc.end :\n            new Position( 1, 1 ),\n        location = new SourceLocation( start, end );\n        \n    Node.call( this, 'Program', location );\n    \n    if( !Array.isArray( body ) ){\n        throw new TypeError( 'body must be an array' );\n    }\n    \n    /**\n     * @member {external:Array<Builder~Statement>}\n     */\n    this.body = body || [];\n}\n\nProgram.prototype = Object.create( Node.prototype );\n\nProgram.prototype.constructor = Program;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the program\n */\nProgram.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.body = this.body.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\n/**\n * @class Builder~ArrayExpression\n * @extends Builder~Expression\n * @param {external:Array<Builder~Expression>} elements A list of expressions\n */\nexport function ArrayExpression( elements, location ){\n    Expression.call( this, 'ArrayExpression', location );\n    \n    if( !( Array.isArray( elements ) ) ){\n        throw new TypeError( 'elements must be a list of expressions' );\n    }\n    \n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.elements = elements;\n}\n\nArrayExpression.prototype = Object.create( Expression.prototype );\n\nArrayExpression.prototype.constructor = ArrayExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the array expression\n */\nArrayExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.elements = this.elements.map( function( element ){\n        return element.toJSON();\n    } );\n    \n    return json;\n};\n\n/**\n * @class Builder~ExpressionStatement\n * @extends Builder~Statement\n */\nexport function ExpressionStatement( expression ){\n    var start = expression.loc.start,\n        end = expression.loc.end,\n        location = new SourceLocation( start, end );\n        \n    Statement.call( this, 'ExpressionStatement', location );\n    \n    if( !( expression instanceof Expression ) ){\n        throw new TypeError( 'argument must be an expression' );\n    }\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.expression = expression;\n}\n\nExpressionStatement.prototype = Object.create( Statement.prototype );\n\nExpressionStatement.prototype.constructor = ExpressionStatement;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the expression statement\n */\nExpressionStatement.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expression = this.expression.toJSON();\n    \n    return json;\n};\n\n/**\n * @class Builder~CallExpression\n * @extends Builder~Expression\n * @param {Builder~Expression} callee\n * @param {Array<Builder~Expression>} args\n */\nexport function CallExpression( callee, args, location ){\n    Expression.call( this, 'CallExpression', location );\n    \n    if( !Array.isArray( args ) ){\n        throw new TypeError( 'arguments must be an array' );\n    }\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.callee = callee;\n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.arguments = args;\n}\n\nCallExpression.prototype = Object.create( Expression.prototype );\n\nCallExpression.prototype.constructor = CallExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the call expression\n */\nCallExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.callee    = this.callee.toJSON();\n    json.arguments = this.arguments.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\n/**\n * @class Builder~MemberExpression\n * @extends Builder~Expression\n * @param {Builder~Expression} object\n * @param {Builder~Expression|Builder~Identifier} property\n * @param {external:boolean} computed=false\n */\nexport function MemberExpression( object, property, computed, location ){\n    Expression.call( this, 'MemberExpression', location );\n    \n    if( computed ){\n        if( !( property instanceof Expression ) ){\n            throw new TypeError( 'property must be an expression when computed is true' );\n        }\n    } else {\n        if( !( property instanceof Identifier ) ){\n            throw new TypeError( 'property must be an identifier when computed is false' );\n        }\n    }\n    \n    /**\n     * @member {Builder~Expression}\n     */\n    this.object = object;\n    /**\n     * @member {Builder~Expression|Builder~Identifier}\n     */\n    this.property = property;\n    /**\n     * @member {external:boolean}\n     */\n    this.computed = computed || false;\n}\n\nMemberExpression.prototype = Object.create( Expression.prototype );\n\nMemberExpression.prototype.constructor = MemberExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the member expression\n */\nMemberExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.object   = this.object.toJSON();\n    json.property = this.property.toJSON();\n    json.computed = this.computed;\n    \n    return json;\n};\n\n/**\n * @class Builder~Identifier\n * @extends Builder~Expression\n * @param {external:string} name The name of the identifier\n */\nexport function Identifier( name, location ){\n    Expression.call( this, 'Identifier', location );\n    \n    if( typeof name !== 'string' ){\n        throw new TypeError( 'name must be a string' );\n    }\n    \n    /**\n     * @member {external:string}\n     */\n    this.name = name;\n}\n\nIdentifier.prototype = Object.create( Expression.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the identifier\n */\nIdentifier.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.name = this.name;\n    \n    return json;\n};\n\n/**\n * @class Builder~Literal\n * @extends Builder~Expression\n * @param {external:string|external:number} value The value of the literal\n */\nexport function Literal( value, location ){\n    Expression.call( this, 'Literal', location );\n    \n    const type = typeof value;\n    \n    if( 'boolean number string'.split( ' ' ).indexOf( type ) === -1 && value !== null && !( value instanceof RegExp ) ){\n        throw new TypeError( 'value must be a boolean, number, string, null, or instance of RegExp' );\n    }\n    \n    /**\n     * @member {external:string|external:number}\n     */\n    this.value = value;\n}\n\nLiteral.prototype = Object.create( Expression.prototype );\n\nLiteral.prototype.constructor = Literal;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the literal\n */\nLiteral.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};\n\n/**\n * @class Builder~SequenceExpression\n * @extends Builder~Expression\n * @param {Array<Builder~Expression>} expressions The expressions in the sequence\n */\nexport function SequenceExpression( expressions, location ){\n    Expression.call( this, 'SequenceExpression', location );\n    \n    if( !( Array.isArray( expressions ) ) ){\n        throw new TypeError( 'expressions must be a list of expressions' );\n    }\n    \n    /**\n     * @member {Array<Builder~Expression>}\n     */\n    this.expressions = expressions;\n}\n\nSequenceExpression.prototype = Object.create( Expression.prototype );\n\nSequenceExpression.prototype.constructor = SequenceExpression;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the sequence expression\n */\nSequenceExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expressions = this.expressions.map( function( expression ){\n        return expression.toJSON();\n    } );\n    \n    return json;\n};\n\n/**\n * @class Builder~Punctuator\n * @extends Builder~Node\n * @param {external:string} value\n */\nexport function Punctuator( value, location ){\n    Node.call( this, 'Punctuator', location );\n    \n    if( typeof value !== 'string' ){\n        throw new TypeError( 'value must be a string' );\n    }\n    \n    /**\n     * @member {external:string}\n     */\n    this.value = value;\n}\n\nPunctuator.prototype = Object.create( Node.prototype );\n\nPunctuator.prototype.constructor = Punctuator;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the punctuator\n */\nPunctuator.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};","'use strict';\n\nimport Null from './null';\nimport { ArrayExpression, CallExpression, ExpressionStatement, Identifier, Literal, MemberExpression, Program, SequenceExpression /*, Punctuator*/ } from './builder/node';\nimport Position from './builder/position';\nimport SourceLocation from './builder/sourceLocation';\n\n/**\n * @class Builder\n * @extends Null\n * @param {Lexer} lexer\n */\nfunction Builder( lexer ){\n    if( !arguments.length ){\n        throw new TypeError( 'lexer must be provided' );\n    }\n    \n    this.lexer = lexer;\n}\n\nBuilder.prototype = new Null();\n\nBuilder.prototype.constructor = Builder;\n\nBuilder.prototype.arrayExpression = function( list ){\n    var // \"+ 1\" to take the ']' into account\n        end = new Position( this.line, list[ list.length - 1 ].loc.end.column + 1 ),\n        location, start;\n    \n    this.consume( '[' );\n    \n    start = new Position( this.line, this.column );\n    location = new SourceLocation( start, end );\n    \n    return new ArrayExpression( list, location );\n};\n\n/**\n * @function\n * @param {external:string} text\n * @returns {Program} The built abstract syntax tree\n */\nBuilder.prototype.build = function( text ){\n    /**\n     * @member {external:string}\n     */\n    this.text = text;\n    /**\n     * @member {external:Array<Token>}\n     */\n    this.tokens = this.lexer.lex( text );\n    \n    //console.log( 'BUILD' );\n    //console.log( '- ', this.text.length, 'CHARS', this.text );\n    //console.log( '- ', this.tokens.length, 'TOKENS', this.tokens );\n    \n    this.column = this.tokens.length;\n    \n    var program = this.program();\n    \n    if( this.tokens.length ){\n        this.throwError( 'Unexpected token ' + this.tokens[ 0 ] + ' remaining' );\n    }\n    \n    return program;\n};\n\n/**\n * @function\n * @returns {CallExpression} The call expression node\n */\nBuilder.prototype.callExpression = function(){\n    var // \"+ 1\" to take the ')' into account\n        end = new Position( this.line, this.column + 1 ),\n        args = this.list( '(' ),\n        callee, location, start;\n        \n    this.consume( '(' );\n    \n    callee = this.expression();\n    \n    start = callee === null ?\n        new Position( this.line, this.column ) :\n        callee.loc.start;\n    \n    //console.log( 'CALL EXPRESSION' );\n    //console.log( '- CALLEE', callee );\n    //console.log( '- ARGUMENTS', args, args.length );\n    \n    location = new SourceLocation( start, end );\n    \n    return new CallExpression( callee, args, location );\n};\n\n/**\n * Removes the next token in the token list. If a comparison is provided, the token will only be returned if the value matches. Otherwise an error is thrown.\n * @function\n * @param {external:string} [expected] An expected comparison value\n * @returns {Token} The next token in the list\n * @throws {SyntaxError} If token did not exist\n */\nBuilder.prototype.consume = function( expected ){\n    if( !this.tokens.length ){\n        this.throwError( 'Unexpected end of expression' );\n    }\n    \n    var token = this.expect( expected );\n    \n    if( !token ){\n        this.throwError( 'Unexpected token ' + token.value + ' consumed' );\n    }\n    \n    return token;\n};\n\n/**\n * Removes the next token in the token list. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Token} The next token in the list or `undefined` if it did not exist\n */\nBuilder.prototype.expect = function( first, second, third, fourth ){\n    var token = this.peek( first, second, third, fourth );\n    \n    if( token ){\n        this.tokens.pop();\n        this.column--;\n        return token;\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Expression} An expression node\n */\nBuilder.prototype.expression = function(){\n    var expression = null,\n        list, next, token;\n    \n    if( next = this.peek() ){\n        if( this.expect( ']' ) ){\n            list = this.list( '[' );\n            if( this.tokens.length === 1 ){\n                expression = this.arrayExpression( list );\n            } else if( list.length > 1 ){\n                expression = this.sequenceExpression( list );\n            } else {\n                expression = list[ 0 ];\n            }\n        } else if( next.type === 'identifier' ){\n            expression = this.identifier();\n            next = this.peek();\n            \n            // Implied member expression\n            if( next && next.type === 'punctuator' ){\n                if( next.value === ')' || next.value === ']' ){\n                    expression = this.memberExpression( expression, false );\n                }\n            }\n        } else if( next.type === 'literal' ){\n            expression = this.literal();\n        }\n        \n        while( ( token = this.expect( ')', '[', '.' ) ) ){\n            if( token.value === ')' ){\n                expression = this.callExpression();\n            } else if( token.value === '[' ){\n                expression = this.memberExpression( expression, true );\n            } else if( token.value === '.' ){\n                expression = this.memberExpression( expression, false );\n            } else {\n                this.throwError( 'Unexpected token ' + token );\n            }\n        }\n    }\n    \n    return expression;\n};\n\n/**\n * @function\n * @returns {ExpressionStatement} An expression statement\n */\nBuilder.prototype.expressionStatement = function(){\n    return new ExpressionStatement( this.expression() );\n};\n\n/**\n * @function\n * @returns {Identifier} An identifier\n * @throws {SyntaxError} If the token is not an identifier\n */\nBuilder.prototype.identifier = function(){\n    var end = new Position( this.line, this.column ),\n        token = this.consume(),\n        location, start;\n    \n    if( !( token.type === 'identifier' ) ){\n        this.throwError( 'Identifier expected' );\n    }\n    \n    start = new Position( this.line, this.column );\n    location = new SourceLocation( start, end );\n    \n    return new Identifier( token.value, location );\n};\n\n/**\n * @function\n * @returns {Literal} The literal node\n */\nBuilder.prototype.literal = function(){\n    var end = new Position( this.line, this.column ),\n        token = this.consume(),\n        literal, location, start, value;\n    \n    if( !( token.type === 'literal' ) ){\n        this.throwError( 'Literal expected' );\n    }\n    \n    value = token.value;\n\n    literal = value[ 0 ] === '\"' || value[ 0 ] === \"'\" ?\n        // String Literal\n        value.substring( 1, value.length - 1 ) :\n        // Numeric Literal\n        parseFloat( value );\n    \n    start = new Position( this.line, this.column );\n    location = new SourceLocation( start, end );\n    \n    return new Literal( literal, location );\n};\n\n/**\n * @function\n * @param {external:string} terminator\n * @returns {external:Array<Literal>} The list of literals\n */\nBuilder.prototype.list = function( terminator ){\n    var list = [];\n    \n    if( this.peek().value !== terminator ){\n        do {\n            list.unshift( this.literal() );\n        } while( this.expect( ',' ) );\n    }\n    \n    return list;\n};\n\n/**\n * @function\n * @param {Expression} property The expression assigned to the property of the member expression\n * @param {external:boolean} computed Whether or not the member expression is computed\n * @returns {MemberExpression} The member expression\n */\nBuilder.prototype.memberExpression = function( property, computed ){\n    var // \"+ 1\" to take the ']' into account, but only for computed member expressions\n        end = new Position( this.line, property.loc.end.column + ( computed ? 1 : 0 ) ),\n        object = this.expression(),\n        start = object.loc.start,\n        location = new SourceLocation( start, end );\n    \n    //console.log( 'MEMBER EXPRESSION' );\n    //console.log( '- OBJECT', object );\n    //console.log( '- PROPERTY', property );\n    //console.log( '- COMPUTED', computed );\n    \n    return new MemberExpression( object, property, computed, location );\n};\n\n/**\n * Provides the next token in the token list _without removing it_. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Lexer~Token} The next token in the list or `undefined` if it did not exist\n */\nBuilder.prototype.peek = function( first, second, third, fourth ){\n    return this.tokens.length ?\n        this.peekAt( 0, first, second, third, fourth ) :\n        undefined;\n};\n\n/**\n * Provides the token at the requested position _without removing it_ from the token list. If comparisons are provided, the token will only be returned if the value matches one of the comparisons.\n * @function\n * @param {external:number} position The position where the token will be peeked\n * @param {external:string} [first] The first comparison value\n * @param {external:string} [second] The second comparison value\n * @param {external:string} [third] The third comparison value\n * @param {external:string} [fourth] The fourth comparison value\n * @returns {Lexer~Token} The token at the requested position or `undefined` if it did not exist\n */\nBuilder.prototype.peekAt = function( position, first, second, third, fourth ){\n    var index, length, token, value;\n    \n    if( typeof position === 'number' && position > -1 ){\n        length = this.tokens.length;\n        index = length - position - 1;\n        \n        if( index > -1 && index < length ){\n            token = this.tokens[ index ];\n            value = token.value;\n            \n            if( value === first || value === second || value === third || value === fourth || ( !first && !second && !third && !fourth ) ){\n                return token;\n            }\n        }\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Program} A program node\n */\nBuilder.prototype.program = function(){\n    var body = [];\n    \n    this.line = 1;\n    \n    while( true ){\n        if( this.tokens.length ){\n            body.push( this.expressionStatement() );\n        } else {\n            return new Program( body );\n        }\n    }\n};\n\nBuilder.prototype.sequenceExpression = function( list ){\n    var // \"- 1\" to take the '[' into account\n        start = new Position( this.line, this.column - 1 ),\n        // \"+ 1\" to take the ']' into account\n        end = new Position( this.line, list[ list.length - 1 ].loc.end.column + 1 ),\n        location = new SourceLocation( start, end );\n    \n    return new SequenceExpression( list, location );\n};\n\n/**\n * @function\n * @param {external:string} message The error message\n * @throws {external:SyntaxError} When it executes\n */\nBuilder.prototype.throwError = function( message ){\n    throw new SyntaxError( message );\n};\n\nexport { Builder as default };","'use strict';\n\n/**\n * @typedef {external:Function} ForEachCallback\n * @param {*} item\n * @param {external:number} index\n */\n\n/**\n * @function\n * @param {Array-Like} list\n * @param {ForEachCallback} callback\n */\nfunction forEach( list, callback ){\n    let index = 0,\n        length = list.length,\n        item;\n    \n    for( ; index < length; index++ ){\n        item = list[ index ];\n        callback( item, index );\n    }\n}\n\nexport { forEach as default };","'use strict';\n\nimport forEach from './forEach';\nimport Null from './null';\n\nvar noop = function(){};\n\n/**\n * @function Interpreter~intepretList\n * @param {Interpreter} interpreter\n * @param {Array-Like} list\n * @param {external:boolean} context\n * @param {external:boolean} create\n * @returns {Array<external:Function>} The interpreted list\n */\nfunction intepretList( interpreter, list, context, create ){\n    var result = [];\n    forEach( list, function( expression, index ){\n        result[ index ] = interpreter.recurse( expression, context, create );\n    } );\n    return result;\n}\n\n/**\n * @class Interpreter\n * @extends Null\n * @param {Builder} builder\n */\nfunction Interpreter( builder ){\n    if( !arguments.length ){\n        throw new TypeError( 'builder cannot be undefined' );\n    }\n    \n    /**\n     * @member {Builder} Interpreter#builder\n     */\n    this.builder = builder;\n}\n\nInterpreter.prototype = new Null();\n\nInterpreter.prototype.constructor = Interpreter;\n\n/**\n * @function\n * @param {external:string} expression\n */\nInterpreter.prototype.compile = function( expression, create ){\n    var program = this.builder.build( expression ),\n        body = program.body,\n        interpreter = this,\n        expressions, fn;\n    \n    if( typeof create !== 'boolean' ){\n        create = false;\n    }\n    \n    /**\n     * @member {external:string}\n     */\n    interpreter.expression = expression;\n    \n    //console.log( '-------------------------------------------------' );\n    //console.log( 'Interpreting ', expression );\n    //console.log( '-------------------------------------------------' );\n    \n    //console.log( 'Program', program.loc );\n    interpreter.eol = program.loc.end.column;\n    \n    switch( body.length ){\n        case 0:\n            fn = noop;\n            break;\n        case 1:\n            fn = interpreter.recurse( body[ 0 ].expression, false, create );\n            break;\n        default:\n            expressions = [];\n            forEach( body, function( expressionStatement, index ){\n                expressions[ index ] = interpreter.recurse( expressionStatement.expression, false, create );\n            } );\n            fn = function( base, value ){\n                var lastValue;\n                \n                forEach( expressions, function( expression ){\n                    lastValue = expression( base, value );\n                } );\n                \n                return lastValue;\n            };\n            break;\n    }\n    \n    return fn;\n};\n\nInterpreter.prototype.recurse = function( node, context, create ){\n    var interpreter = this,\n        isRightMost = false,\n        \n        args, fn, left, right;\n    \n    //console.log( 'NODE', node.type, node.loc.end.column );\n        \n    switch( node.type ){\n        case 'ArrayExpression': {\n            args = intepretList( interpreter, node.elements, false );\n            \n            return function getArrayExpression( base, value ){\n                //console.log( 'Getting ARRAY EXPRESSION' );\n                var result = [], name;\n                forEach( args, function( arg, index ){\n                    name = arg( base, value );\n                    if( create && !( name in base ) ){\n                        base[ name ] = node.order === 1 ?\n                            value :\n                            {};\n                    }\n                    result[ index ] = base[ name ];\n                } );\n                \n                if( result.length === 1 ){\n                    result = result[ 0 ];\n                }\n                //console.log( '- ARRAY EXPRESSION RESULT', result );\n                return context ?\n                    { value: result } :\n                    result;\n            };\n        }\n        case 'CallExpression': {\n            args = intepretList( interpreter, node.arguments, false );\n            right = interpreter.recurse( node.callee, true, create );\n            \n            return function getCallExpression( base, value ){\n                //console.log( 'Getting CALL EXPRESSION' );\n                //console.log( '- RIGHT', right.name );\n                var values = [],\n                    rhs = right( base, value ),\n                    result;\n                //console.log( '- RHS', rhs );\n                if( typeof rhs.value === 'function' ){\n                    values = [];\n                    \n                    forEach( args, function( arg, index ){\n                        values[ index ] = arg( base );\n                    } );\n                    \n                    result = rhs.value.apply( rhs.context, values );\n                } else if( create && typeof rhs.value === 'undefined' ){\n                    throw new Error( 'cannot create call expressions' );\n                } else {\n                    throw new TypeError( 'call expression must be a function' );\n                }\n                //console.log( '- CALL RESULT', result );\n                return context ?\n                    { value: result }:\n                    result;\n            };\n        }\n        \n        case 'ExpressionStatement': {\n            left = interpreter.recurse( node.expression, context, create );\n            return function getExpressionStatement( base, value ){\n                //console.log( 'Getting EXPRESSION STATEMENT' );\n                //console.log( '- EXPRESSION STATEMENT LEFT', left.name );\n                var result = left( base, value );\n                //console.log( '- EXPRESSION STATEMENT RESULT', result );\n                return result;\n            };\n        }\n        \n        case 'Identifier': {\n            return function getIdentifier( base, value ){\n                //console.log( 'Getting IDENTIFIER' );\n                var name = node.name,\n                    result;\n                if( typeof base !== 'undefined' ){\n                    if( create && !( name in base ) ){\n                        base[ name ] = node.order === 1 ?\n                            value :\n                            {};\n                    }\n                    result = base[ name ];\n                }\n                //console.log( '- NAME', name );\n                //console.log( '- IDENTIFIER RESULT', result );\n                return context ?\n                    { context: base, name: name, value: result } :\n                    result;\n            };\n        }\n        case 'Literal': {\n            return function getLiteral( base ){\n                var result = node.value;\n                //console.log( 'Getting LITERAL' );\n                //console.log( '- LITERAL RESULT', result );\n                return context ?\n                    { context: undefined, name: undefined, value: result } :\n                    result;\n            };\n        }\n        case 'MemberExpression': {\n            left = interpreter.recurse( node.object, false, create );\n            isRightMost = node.loc.end.column === interpreter.eol;\n            // Computed\n            if( node.computed ){\n                right = interpreter.recurse( node.property, false, create );\n                fn = function getComputedMember( base, value ){\n                    //console.log( 'Getting COMPUTED MEMBER' );\n                    //console.log( '- COMPUTED LEFT', left.name );\n                    //console.log( '- COMPUTED RIGHT', right.name );\n                    var lhs = left( base, value ),\n                        result, rhs;\n                    //console.log( '- COMPUTED LHS', lhs );\n                    if( typeof lhs !== 'undefined' ){\n                        rhs = right( base, value );\n                        //console.log( '- COMPUTED RHS', rhs );\n                        if( Array.isArray( lhs ) ){\n                            result = [];\n                            \n                            if( Array.isArray( rhs ) ){\n                                forEach( rhs, function( item, index ){\n                                    if( create && !( item in lhs ) ){\n                                        lhs[ item ] = isRightMost ?\n                                            value :\n                                            {};\n                                    }\n                                    result[ index ] = lhs[ item ];\n                                } );\n                                //console.log( '-- LIST:LIST', result );\n                            } else {\n                                if( typeof rhs === 'number' ){\n                                    if( create && !( rhs in lhs ) ){\n                                        lhs[ rhs ] = isRightMost ?\n                                            value :\n                                            {};\n                                    }\n                                    result[ 0 ] = lhs[ rhs ];\n                                } else {\n                                    forEach( lhs, function( item, index ){\n                                        if( create && !( rhs in item ) ){\n                                            item[ rhs ] = isRightMost ?\n                                                value :\n                                                {};\n                                        }\n                                        result[ index ] = item[ rhs ];\n                                    } );\n                                }\n                                //console.log( '-- LIST:VALUE', result );\n                            }\n                            \n                            if( result.length === 1 ){\n                                result = result[ 0 ];\n                            }\n                        } else if( Array.isArray( rhs ) ){\n                            result = [];\n                            \n                            forEach( rhs, function( item, index ){\n                                if( create && !( item in lhs ) ){\n                                    lhs[ item ] = isRightMost ?\n                                        value :\n                                        {};\n                                }\n                                result[ index ] = lhs[ item ];\n                            } );\n                            //console.log( '-- VALUE:LIST', result );\n                            if( result.length === 1 ){\n                                result = result[ 0 ];\n                            }\n                        } else {\n                            if( create && !( rhs in lhs ) ){\n                                lhs[ rhs ] = isRightMost ?\n                                    value :\n                                    {};\n                            }\n                            result = lhs[ rhs ];\n                            //console.log( '-- VALUE:VALUE', result );\n                        }\n                    }\n                    //console.log( '- COMPUTED RESULT', result );\n                    return context ?\n                        { context: lhs, name: rhs, value: result } :\n                        result;\n                };\n            \n            // Non-computed\n            } else {\n                right = node.property.name;\n                isRightMost = node.property.loc.end.column === interpreter.eol;\n                fn = function getNonComputedMember( base, value ){\n                    //console.log( 'Getting NON-COMPUTED MEMBER' );\n                    //console.log( '- NON-COMPUTED LEFT', left.name );\n                    //console.log( '- NON-COMPUTED RIGHT', right );\n                    var lhs = left( base, value ),\n                        result;\n                    //console.log( '- NON-COMPUTED LHS', lhs );\n                    if( typeof lhs !== 'undefined' ){\n                        if( Array.isArray( lhs ) ){\n                            result = [];\n                            forEach( lhs, function( item, index ){\n                                if( create && !( right in item ) ){\n                                    item[ right ] = isRightMost ?\n                                        value :\n                                        {};\n                                }\n                                result[ index ] = item[ right ];\n                            } );\n                            //console.log( '-- LIST:VALUE', result );\n                        } else {\n                            if( create && !( right in lhs ) ){\n                                lhs[ right ] = isRightMost ?\n                                    value :\n                                    {};\n                            }\n                            result = lhs[ right ];\n                            //console.log( '-- VALUE:VALUE', result );\n                        }\n                    }\n                    //console.log( '- NON-COMPUTED RESULT', result );\n                    return context ?\n                        { context: lhs, name: right, value: result } :\n                        result;\n                };\n            }\n            \n            return fn;\n        }\n        case 'SequenceExpression': {\n            args = intepretList( interpreter, node.expressions, false );\n            \n            return function getSequenceExpression( base, value ){\n                //console.log( 'Getting SEQUENCE EXPRESSION' );\n                var result = [];\n                forEach( args, function( arg, index ){\n                    result[ index ] = arg( base );\n                } );\n                //console.log( '- SEQUENCE RESULT', result );\n                return context ?\n                    { value: result } :\n                    result;\n            };\n        }\n        default:\n            this.throwError( 'Unknown node type ' + node.type );\n    }\n};\n\nInterpreter.prototype.throwError = function( message ){\n    throw new Error( message );\n};\n\nexport { Interpreter as default };","'use strict';\n\nimport Null from './null';\nimport Lexer from './lexer';\nimport Builder from './builder';\nimport Interpreter from './interpreter';\n\nvar lexer = new Lexer(),\n    builder = new Builder( lexer ),\n    intrepreter = new Interpreter( builder );\n\n/**\n * @class KeyPathExp\n * @extends Null\n * @param {external:string} pattern\n * @param {external:string} flags\n */\nfunction KeyPathExp( pattern, flags ){\n    typeof pattern !== 'string' && ( pattern = '' );\n    typeof flags !== 'string' && ( flags = '' );\n    \n    Object.defineProperties( this, {\n        'flags': {\n            value: flags,\n            configurable: false,\n            enumerable: true,\n            writable: false\n        },\n        'source': {\n            value: pattern,\n            configurable: false,\n            enumerable: true,\n            writable: false\n        },\n        'getter': {\n            value: intrepreter.compile( pattern, false ),\n            configurable: false,\n            enumerable: false,\n            writable: false\n        },\n        'setter': {\n            value: intrepreter.compile( pattern, true ),\n            configurable: false,\n            enumerable: false,\n            writable: false\n        }\n    } );\n}\n\nKeyPathExp.prototype = new Null();\n\nKeyPathExp.prototype.constructor = KeyPathExp;\n\n/**\n * @function\n */\nKeyPathExp.prototype.get = function( target ){\n    return this.getter( target );\n};\n\n/**\n * @function\n */\nKeyPathExp.prototype.set = function( target, value ){\n    return this.setter( target, value );\n};\n\n/**\n * @function\n */\nKeyPathExp.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.flags = this.flags;\n    json.source = this.source;\n    \n    return json;\n};\n\n/**\n * @function\n */\nKeyPathExp.prototype.toString = function(){\n    return this.source;\n};\n\nexport { KeyPathExp as default };","'use strict';\n\nimport KeyPathExp from './keypath';\nimport Null from './null';\n\nvar cache = new Null();\n\n/**\n * @typedef {external:Function} KeyPathCallback\n * @param {*} target The object on which the keypath will be executed\n * @param {*} [value] The optional value that will be set at the keypath\n * @returns {*} The value at the end of the keypath or undefined if the value was being set\n */\n\n/**\n * A template literal tag for keypath processing.\n * @function\n * @param {Array<external:string>} literals\n * @param {external:Array} values\n * @returns {KeyPathCallback}\n * @example\n * const object = { foo: { bar: { qux: { baz: 'fuz' } } } },\n *  getBaz = ( target ) => kp`foo.bar.qux.baz`( target );\n * \n * console.log( getBaz( object ) ); // \"fuz\"\n */\nfunction kp( literals/*, ...values*/ ){\n    var keypath, kpex, values;\n    \n    if( arguments.length > 1 ){\n        var index = 0,\n            length = arguments.length - 1;\n        \n        values = new Array( length );\n        \n        for( ; index < length; index++ ){\n            values[ index ] = arguments[ index + 1 ];\n        }\n        \n        keypath = literals.reduce( function( accumulator, part, index ){\n            return accumulator + values[ index - 1 ] + part;\n        } );\n    } else {\n        values = [];\n        keypath = literals[ 0 ];\n    }\n    \n    kpex = keypath in cache ?\n        cache[ keypath ] :\n        cache[ keypath ] = new KeyPathExp( keypath );\n    \n    return function( target, value ){\n        return arguments.length > 1 ?\n            kpex.set( target, value ) :\n            kpex.get( target );\n    };\n}\n\nexport { kp as default };\n"],"names":["Identifier","Literal"],"mappings":"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","sourceRoot":"/source/"}