{"version":3,"file":"interpreter-umd.js","sources":["forEach.js","null.js","interpreter.js"],"sourcesContent":["'use strict';\n\nexport default function forEach( arrayLike, callback ){\n    let index = 0,\n        length = arrayLike.length,\n        item;\n    \n    for( ; index < length; index++ ){\n        item = arrayLike[ index ];\n        callback( item );\n    }\n}","'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nexport default function Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;","'use strict';\n\nimport forEach from './forEach';\nimport Null from './null';\n\nconst noop = function(){},\n\n    /**\n     * @namespace\n     */\n    interpret = new Null();\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.ArrayExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.elements, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'ARRAY EXPRESSION' );\n        \n        let result = [];\n        \n        forEach( args, function( arg ){\n            result.push( base[ arg( base, value ) ] );\n        } );\n        \n        if( result.length === 1 ){\n            result = result[ 0 ];\n        }\n        \n        //console.log( '- ARRAY RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.CallExpression = function( interpreter, node, context ){\n    const args = [];\n            \n    forEach( node.arguments, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    const right = interpreter.recurse( node.callee, true );\n    \n    return function( base, value ){\n        //console.log( 'CALL EXPRESSION' );\n        const rhs = right( base, value );\n        let result;\n        \n        if( typeof rhs.value === 'function' ){\n            const values = args.map( function( arg ){\n                return arg( base, value );\n            } );\n            result = rhs.value.apply( rhs.context, values );\n        } else if( typeof value !== 'undefined' ){\n            throw new Error( 'cannot create functions' );\n        }\n        \n        //console.log( '- CALL RESULT', result );\n        \n        return context ?\n            { value: result }:\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Identifier = function( interpreter, node, context ){\n    const name = node.name;\n    return function( base, value ){\n        //console.log( 'IDENTIFIER' );\n        let result;\n        \n        if( typeof base !== 'undefined' ){\n            if( typeof value !== 'undefined' && !( name in base ) ){\n                base[ name ] = new Null();\n            }\n            \n            result = base[ name ];\n        }\n        \n        //console.log( '- NAME', name );\n        //console.log( '- IDENTIFIER RESULT', result );\n        \n        return context ?\n            { context: base, name: name, value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Literal = function( interpreter, node, context ){\n    const value = node.value;\n    return function(){\n        //console.log( 'LITERAL' );\n        //console.log( '- LITERAL RESULT', value );\n        return context ?\n            { context: undefined, name: undefined, value: value } :\n            value;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.MemberExpression = function( interpreter, node, context ){\n    const left = interpreter.recurse( node.object, false );\n    \n    let fn, lhs, result, rhs, right;\n    \n    if( node.computed ){\n        right = interpreter.recurse( node.property, false );\n        fn = function( base, value ){\n            //console.log( 'COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                rhs = right( base, value );\n                \n                if( typeof value !== 'undefined' && !( rhs in lhs ) ){\n                    lhs[ rhs ] = new Null();\n                }\n                \n                //console.log( '- COMPUTED RHS', rhs );\n                \n                if( Array.isArray( lhs ) ){\n                    // Sequence expression\n                    if( Array.isArray( rhs ) ){\n                        result = rhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    // Literal expression\n                    } else if( lhs.length === 1 ){\n                        result = lhs[ 0 ];\n                    // Array expression\n                    } else {\n                        result = lhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    }\n                } else {\n                    result = lhs[ rhs ];\n                }\n            }\n            \n            //console.log( '- COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: rhs, value: result } :\n                result;\n        };\n    } else {\n        right = node.property.name;\n        fn = function( base, value ){\n            //console.log( 'NON-COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- NON-COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                if( typeof value !== 'undefined' && !( right in lhs ) ){\n                    lhs[ right ] = value || new Null();\n                }\n                \n                //console.log( '- NON-COMPUTED RIGHT', right );\n                \n                if( Array.isArray( lhs ) ){\n                    result = lhs.map( function( item ){\n                       return item[ right ];\n                    } );\n                } else {\n                    result = lhs[ right ];\n                }\n            }\n            \n            //console.log( '- NON-COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: right, value: result } :\n                result;\n        };\n    }\n    \n    return fn;\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.SequenceExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.expressions, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'SEQUENCE EXPRESSION' );\n        \n        const result = [];\n        \n        forEach( args, function( arg ){\n            result.push( arg( base, value ) );\n        } );\n        \n        //console.log( '- SEQUENCE RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @class Interpreter\n * @extends Null\n * @param {Builder} builder\n */\nfunction Interpreter( builder ){\n    if( !arguments.length ){\n        throw new TypeError( 'builder cannot be undefined' );\n    }\n    \n    this.builder = builder;\n}\n\nInterpreter.prototype = new Null();\n\nInterpreter.prototype.constructor = Interpreter;\n\n/**\n * @function\n * @param {external:string} expression\n */\nInterpreter.prototype.compile = function( expression ){\n    const ast = this.builder.build( expression ),\n        body = ast.body,\n        interpreter = this;\n    \n    let fn;\n    \n    interpreter.expression = expression;\n    \n    switch( body.length ){\n        case 0:\n            fn = noop;\n            break;\n        case 1:\n            fn = interpreter.recurse( body[ 0 ].expression, false );\n            break;\n        default:\n            const expressions = [];\n            forEach( body, function( statement ){\n                expressions.push( interpreter.recurse( statement.expression, false ) );\n            } );\n            fn = function( base, value ){\n                let lastValue;\n                \n                forEach( expressions, function( expression ){\n                    lastValue = expression( base, value );\n                } );\n                \n                return lastValue;\n            };\n            break;\n    }\n    \n    return fn;\n};\n\nInterpreter.prototype.recurse = function( node, context ){\n    ////console.log( 'RECURSE', node );\n    \n    if( !( node.type in interpret ) ){\n        this.throwError( `Unknown node type ${ node.type }` );\n    }\n    \n    return interpret[ node.type ]( this, node, context );\n};\n\nInterpreter.prototype.throwError = function( message ){\n    throw new Error( message );\n};\n\nexport { Interpreter as default };"],"names":["forEach","arrayLike","callback","index","length","item","Null","prototype","Object","create","constructor","noop","interpret","ArrayExpression","interpreter","node","context","args","elements","expr","push","recurse","base","value","result","arg","CallExpression","arguments","right","callee","rhs","values","map","apply","Error","Identifier","name","Literal","undefined","MemberExpression","left","object","fn","lhs","computed","property","Array","isArray","SequenceExpression","expressions","Interpreter","builder","TypeError","compile","expression","ast","build","body","statement","lastValue","type","throwError","message"],"mappings":"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","sourceRoot":"/source/"}