{"version":3,"file":"interpreter-umd.js","sources":["forEach.js","null.js","interpreter.js"],"sourcesContent":["'use strict';\n\nexport default function forEach( arrayLike, callback ){\n    let index = 0,\n        length = arrayLike.length,\n        item;\n    \n    for( ; index < length; index++ ){\n        item = arrayLike[ index ];\n        callback( item );\n    }\n}","'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nexport default function Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;","'use strict';\n\nimport forEach from './forEach';\nimport Null from './null';\n\nconst noop = function(){},\n\n    /**\n     * @namespace\n     */\n    interpret = new Null();\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.ArrayExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.elements, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        console.log( 'ARRAY EXPRESSION' );\n        \n        let result = [];\n        \n        forEach( args, function( arg ){\n            result.push( base[ arg( base, value ) ] );\n        } );\n        \n        if( result.length === 1 ){\n            result = result[ 0 ];\n        }\n        \n        console.log( '- ARRAY RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.CallExpression = function( interpreter, node, context ){\n    const args = [];\n            \n    forEach( node.arguments, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    const right = interpreter.recurse( node.callee, true );\n    \n    return function( base, value ){\n        console.log( 'CALL EXPRESSION' );\n        const rhs = right( base, value );\n        let result;\n        \n        if( typeof rhs.value === 'function' ){\n            const values = args.map( function( arg ){\n                return arg( base, value );\n            } );\n            result = rhs.value.apply( rhs.context, values );\n        } else if( typeof value !== 'undefined' ){\n            throw new Error( 'cannot create functions' );\n        }\n        \n        console.log( '- CALL RESULT', result );\n        \n        return context ?\n            { value: result }:\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Identifier = function( interpreter, node, context ){\n    const name = node.name;\n    return function( base, value ){\n        console.log( 'IDENTIFIER' );\n        let result;\n        \n        if( typeof base !== 'undefined' ){\n            if( typeof value !== 'undefined' && !( name in base ) ){\n                base[ name ] = new Null();\n            }\n            \n            result = base[ name ];\n        }\n        \n        console.log( '- NAME', name );\n        console.log( '- IDENTIFIER RESULT', result );\n        \n        return context ?\n            { context: base, name: name, value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Literal = function( interpreter, node, context ){\n    const value = node.value;\n    return function(){\n        console.log( 'LITERAL' );\n        console.log( '- LITERAL RESULT', value );\n        return context ?\n            { context: undefined, name: undefined, value: value } :\n            value;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.MemberExpression = function( interpreter, node, context ){\n    const left = interpreter.recurse( node.object, false );\n    \n    let fn, lhs, result, rhs, right;\n    \n    if( node.computed ){\n        right = interpreter.recurse( node.property, false );\n        fn = function( base, value ){\n            console.log( 'COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            console.log( '- COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                rhs = right( base, value );\n                \n                if( typeof value !== 'undefined' && !( rhs in lhs ) ){\n                    lhs[ rhs ] = new Null();\n                }\n                \n                console.log( '- COMPUTED RHS', rhs );\n                \n                if( Array.isArray( lhs ) ){\n                    // Sequence expression\n                    if( Array.isArray( rhs ) ){\n                        result = rhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    // Literal expression\n                    } else if( lhs.length === 1 ){\n                        result = lhs[ 0 ];\n                    // Array expression\n                    } else {\n                        result = lhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    }\n                } else {\n                    result = lhs[ rhs ];\n                }\n            }\n            \n            console.log( '- COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: rhs, value: result } :\n                result;\n        };\n    } else {\n        right = node.property.name;\n        fn = function( base, value ){\n            console.log( 'NON-COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            console.log( '- NON-COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                if( typeof value !== 'undefined' && !( right in lhs ) ){\n                    lhs[ right ] = value || new Null();\n                }\n                \n                console.log( '- NON-COMPUTED RIGHT', right );\n                \n                if( Array.isArray( lhs ) ){\n                    result = lhs.map( function( item ){\n                       return item[ right ];\n                    } );\n                } else {\n                    result = lhs[ right ];\n                }\n            }\n            \n            console.log( '- NON-COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: right, value: result } :\n                result;\n        };\n    }\n    \n    return fn;\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.SequenceExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.expressions, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        console.log( 'SEQUENCE EXPRESSION' );\n        \n        const result = [];\n        \n        forEach( args, function( arg ){\n            result.push( arg( base, value ) );\n        } );\n        \n        console.log( '- SEQUENCE RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @class Interpreter\n * @extends Null\n * @param {Builder} builder\n */\nfunction Interpreter( builder ){\n    if( !arguments.length ){\n        throw new TypeError( 'builder cannot be undefined' );\n    }\n    \n    this.builder = builder;\n}\n\nInterpreter.prototype = new Null();\n\nInterpreter.prototype.constructor = Interpreter;\n\n/**\n * @function\n * @param {external:string} expression\n */\nInterpreter.prototype.compile = function( expression ){\n    const ast = this.builder.build( expression ),\n        body = ast.body,\n        interpreter = this;\n    \n    let fn;\n    \n    interpreter.expression = expression;\n    \n    switch( body.length ){\n        case 0:\n            fn = noop;\n            break;\n        case 1:\n            fn = interpreter.recurse( body[ 0 ].expression, false );\n            break;\n        default:\n            const expressions = [];\n            forEach( body, function( statement ){\n                expressions.push( interpreter.recurse( statement.expression, false ) );\n            } );\n            fn = function( base, value ){\n                let lastValue;\n                \n                forEach( expressions, function( expression ){\n                    lastValue = expression( base, value );\n                } );\n                \n                return lastValue;\n            };\n            break;\n    }\n    \n    return fn;\n};\n\nInterpreter.prototype.recurse = function( node, context ){\n    //console.log( 'RECURSE', node );\n    \n    if( !( node.type in interpret ) ){\n        this.throwError( `Unknown node type ${ node.type }` );\n    }\n    \n    return interpret[ node.type ]( this, node, context );\n};\n\nInterpreter.prototype.throwError = function( message ){\n    throw new Error( message );\n};\n\nexport { Interpreter as default };"],"names":["forEach","arrayLike","callback","index","length","item","Null","prototype","Object","create","constructor","noop","interpret","ArrayExpression","interpreter","node","context","args","elements","expr","push","recurse","base","value","log","result","arg","CallExpression","arguments","right","callee","rhs","values","map","apply","Error","Identifier","name","Literal","undefined","MemberExpression","left","object","fn","lhs","computed","property","Array","isArray","SequenceExpression","expressions","Interpreter","builder","TypeError","compile","expression","ast","build","body","statement","lastValue","type","throwError","message"],"mappings":"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","sourceRoot":"/source/"}