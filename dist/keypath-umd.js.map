{"version":3,"file":"keypath-umd.js","sources":["null.js","uuid.js","lexer/token.js","lexer.js","builder/node.js","builder.js","forEach.js","interpreter.js","keypath.js"],"sourcesContent":["'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nexport default function Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;","'use strict';\n\nlet id = 0;\n\nexport default function nextId(){\n    return ++id;\n}","'use strict';\n\nimport Null from '../null';\nimport nextId from '../uuid';\n\n/**\n * @class Token\n * @extends Null\n * @param {external:string} type The type of the token\n * @param {*} value The value of the token\n * @throws {external:TypeError} If `type` is not a string\n * @throws {external:TypeError} If `value` is undefined.\n */\nfunction Token( type, value ){\n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    if( typeof value === 'undefined' ){\n        throw new TypeError( 'value cannot be undefined' );\n    }\n    \n    this.id = nextId();\n    this.type = type;\n    this.value = value;\n    this.length = value.length;\n}\n\nToken.prototype = new Null();\n\nToken.prototype.constructor = Token;\n\nToken.prototype.equals = function( token ){\n    return token instanceof Token && this.valueOf() === token.valueOf();\n};\n\n/**\n * @function\n * @param {external:string} type\n * @returns {external:boolean} Whether or not the token is the `type` provided.\n */\nToken.prototype.is = function( type ){\n    return this.type === type;\n};\n\nToken.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.type = this.type;\n    json.value = this.value;\n    \n    return json;\n};\n\nToken.prototype.toString = function(){\n    return String( this.value );\n};\n\nToken.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Token as default };\n\nexport function Identifier( value ){\n    Token.call( this, 'identifier', value );\n}\n\nIdentifier.prototype = Object.create( Token.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\nexport function Literal( value ){\n    Token.call( this, 'literal', value );\n}\n\nLiteral.prototype = Object.create( Token.prototype );\n\nLiteral.prototype.constructor = Literal;\n\nexport function Punctuator( value ){\n    Token.call( this, 'punctuator', value );\n}\n\nPunctuator.prototype = Object.create( Token.prototype );\n\nPunctuator.prototype.constructor = Punctuator;","'use strict';\n\nimport Null from './null';\nimport { Identifier, Literal, Punctuator } from './lexer/token';\n\n/**\n * @class LexerError\n * @extends SyntaxError\n * @param {external:string} message The error message\n */\nfunction LexerError( message ){\n    SyntaxError.call( this, message );    \n}\n\nLexerError.prototype = Object.create( SyntaxError.prototype );\n\n/**\n * @class Lexer\n * @extends Null\n */\nexport default function Lexer(){\n    this.buffer = '';\n}\n\nLexer.prototype = new Null();\n\nLexer.prototype.constructor = Lexer;\n\nLexer.prototype.lex = function( text ){\n    this.buffer = text;\n    this.index = 0;\n    this.tokens = [];\n    \n    const length = this.buffer.length;\n    let word = '',\n        char;\n    \n    while( this.index < length ){\n        char = this.buffer[ this.index ];\n        \n        // Identifier\n        if( this.isIdentifier( char ) ){\n            word = this.read( function( char ){\n                return !this.isIdentifier( char ) && !this.isNumeric( char );\n            } );\n            \n            this.tokens.push( new Identifier( word ) );\n        \n        // Punctuator\n        } else if( this.isPunctuator( char ) ){\n            this.tokens.push( new Punctuator( char ) );\n            this.index++;\n        \n        // Quoted String\n        } else if( this.isQuote( char ) ){\n            let quote = char;\n            \n            this.index++;\n            \n            word = this.read( function( char ){\n                return char === quote;\n            } );\n            \n            this.tokens.push( new Literal( `${ quote }${ word }${ quote }` ) );\n            \n            this.index++;\n        \n        // Numeric\n        } else if( this.isNumeric( char ) ){\n            word = this.read( function( char ){\n                return !this.isNumeric( char );\n            } );\n            \n            this.tokens.push( new Literal( word ) );\n        \n        // Whitespace\n        } else if( this.isWhitespace( char ) ){\n            this.index++;\n        \n        // Error\n        } else {\n            this.throwError( `\"${ char }\" is an invalid character` );\n        }\n        \n        word = '';\n    }\n    \n    return this.tokens;\n};\n\nLexer.prototype.isIdentifier = function( char ){\n    return 'a' <= char && char <= 'z' || 'A' <= char && char <= 'Z' || '_' === char || char === '$';\n};\n\nLexer.prototype.isPunctuator = function( char ){\n    return char === '.' || char === '(' || char === ')' || char === '[' || char === ']' || char === ',' || char === '%';\n};\n\nLexer.prototype.isWhitespace = function( char ){\n    return char === ' ' || char === '\\r' || char === '\\t' || char === '\\n' || char === '\\v' || char === '\\u00A0';\n};\n\nLexer.prototype.isQuote = function( char ){\n    return char === '\"' || char === \"'\";\n};\n\nLexer.prototype.isNumeric = function( char ){\n    return '0' <= char && char <= '9';\n};\n\nLexer.prototype.read = function( until ){\n    let start = this.index,\n        char;\n    \n    while( this.index < this.buffer.length ){\n        char = this.buffer[ this.index ];\n        \n        if( until.call( this, char ) ){\n            break;\n        }\n        \n        this.index++;\n    }\n    \n    return this.buffer.slice( start, this.index );\n};\n\nLexer.prototype.throwError = function( message ){\n    throw new LexerError( message );\n};\n\nLexer.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.buffer = this.buffer;\n    json.tokens = this.tokens.map( function( token ){\n        return token.toJSON();\n    } );\n    \n    return json;\n};\n","'use strict';\n\nimport Null from '../null';\nimport nextId from '../uuid';\n\n/**\n * @class Node\n * @extends Null\n * @param {external:string} type The type of node\n */\nfunction Node( type ){\n    \n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    this.id = nextId();\n    this.type = type;\n}\n\nNode.prototype = new Null();\n\nNode.prototype.constructor = Node;\n\nNode.prototype.equals = function( node ){\n    return node instanceof Node && this.valueOf() === node.valueOf();\n};\n\nNode.prototype.is = function( type ){\n    return this.type === type;\n};\n\nNode.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.type = this.type;\n    \n    return json;\n};\n\nNode.prototype.toString = function(){\n    return String( this.type );\n};\n\nNode.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Node as default };\n\nfunction Statement( statementType ){\n    Node.call( this, statementType );\n}\n\nStatement.prototype = Object.create( Node.prototype );\n\nStatement.prototype.constructor = Statement;\n\nfunction Expression( expressionType ){\n    Node.call( this, expressionType );\n}\n\nExpression.prototype = Object.create( Node.prototype );\n\nExpression.prototype.constructor = Expression;\n\nexport function Program( body ){\n    Node.call( this, 'Program' );\n    \n    if( !Array.isArray( body ) ){\n        throw new TypeError( 'body must be an array' );\n    }\n    \n    this.body = body || [];\n}\n\nProgram.prototype = Object.create( Node.prototype );\n\nProgram.prototype.constructor = Program;\n\nProgram.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.body = this.body.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\nexport function ArrayExpression( elements ){\n    Expression.call( this, 'ArrayExpression' );\n    \n    if( !( Array.isArray( elements ) ) ){\n        throw new TypeError( 'elements must be a list of expressions' );\n    }\n    \n    this.elements = elements;\n}\n\nArrayExpression.prototype = Object.create( Expression.prototype );\n\nArrayExpression.prototype.constructor = ArrayExpression;\n\nArrayExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.elements = this.elements.map( function( element ){\n        return element.toJSON();\n    } );\n    \n    return json;\n};\n\nexport function ExpressionStatement( expression ){\n    Statement.call( this, 'ExpressionStatement' );\n    \n    if( !( expression instanceof Expression ) ){\n        throw new TypeError( 'argument must be an expression' );\n    }\n    \n    this.expression = expression;\n}\n\nExpressionStatement.prototype = Object.create( Statement.prototype );\n\nExpressionStatement.prototype.constructor = ExpressionStatement;\n\nExpressionStatement.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expression = this.expression.toJSON();\n    \n    return json;\n};\n\nexport function CallExpression( callee, args ){\n    Expression.call( this, 'CallExpression' );\n    \n    if( !Array.isArray( args ) ){\n        throw new TypeError( 'arguments must be an array' );\n    }\n    \n    this.callee = callee;\n    this.arguments = args;\n}\n\nCallExpression.prototype = Object.create( Expression.prototype );\n\nCallExpression.prototype.constructor = CallExpression;\n\nCallExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.callee    = this.callee.toJSON();\n    json.arguments = this.arguments.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\nexport function MemberExpression( object, property, computed ){\n    Expression.call( this, 'MemberExpression' );\n    \n    if( computed ){\n        if( !( property instanceof Expression ) ){\n            throw new TypeError( 'property must be an expression when computed is true' );\n        }\n    } else {\n        if( !( property instanceof Identifier ) ){\n            throw new TypeError( 'property must be an identifier when computed is false' );\n        }\n    }\n    \n    this.object = object;\n    this.property = property;\n    this.computed = computed || false;\n}\n\nMemberExpression.prototype = Object.create( Expression.prototype );\n\nMemberExpression.prototype.constructor = MemberExpression;\n\nMemberExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.object   = this.object.toJSON();\n    json.property = this.property.toJSON();\n    json.computed = this.computed;\n    \n    return json;\n};\n\nexport function Identifier( name ){\n    Expression.call( this, 'Identifier' );\n    \n    if( typeof name !== 'string' ){\n        throw new TypeError( 'name must be a string' );\n    }\n    \n    this.name = name;\n}\n\nIdentifier.prototype = Object.create( Expression.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\nIdentifier.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.name = this.name;\n    \n    return json;\n};\n\nexport function Literal( value ){\n    Expression.call( this, 'Literal' );\n    \n    const type = typeof value;\n    \n    if( 'boolean number string'.split( ' ' ).indexOf( type ) === -1 && value !== null && !( value instanceof RegExp ) ){\n        throw new TypeError( 'value must be a boolean, number, string, null, or instance of RegExp' );\n    }\n    \n    this.value = value;\n}\n\nLiteral.prototype = Object.create( Expression.prototype );\n\nLiteral.prototype.constructor = Literal;\n\nLiteral.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};\n\nexport function SequenceExpression( expressions ){\n    Expression.call( this, 'SequenceExpression' );\n    \n    if( !( Array.isArray( expressions ) ) ){\n        throw new TypeError( 'expressions must be a list of expressions' );\n    }\n    \n    this.expressions = expressions;\n}\n\nSequenceExpression.prototype = Object.create( Expression.prototype );\n\nSequenceExpression.prototype.constructor = SequenceExpression;\n\nSequenceExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expressions = this.expressions.map( function( expression ){\n        return expression.toJSON();\n    } );\n    \n    return json;\n};\n\nexport function Punctuator( value ){\n    Node.call( this, 'Punctuator' );\n    \n    if( typeof value !== 'string' ){\n        throw new TypeError( 'value must be a string' );\n    }\n    \n    this.value = value;\n}\n\nPunctuator.prototype = Object.create( Node.prototype );\n\nPunctuator.prototype.constructor = Punctuator;\n\nPunctuator.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};","'use strict';\n\nimport Null from './null';\nimport { ArrayExpression, CallExpression, ExpressionStatement, Identifier, Literal, MemberExpression, Program, SequenceExpression /*, Punctuator*/ } from './builder/node';\n\n/**\n * @class Builder\n * @extends Null\n * @param {Lexer} lexer\n */\nfunction Builder( lexer ){\n    if( !arguments.length ){\n        throw new TypeError( 'lexer must be provided' );\n    }\n    \n    this.lexer = lexer;\n}\n\nBuilder.prototype = new Null();\n\nBuilder.prototype.constructor = Builder;\n\nBuilder.prototype.arrayExpression = function(){\n    const args = this.bracketList();\n    return new ArrayExpression( args );\n};\n\nBuilder.prototype.build = function( text ){\n    this.buffer = text;\n    this.tokens = this.lexer.lex( text );\n    \n    const program = this.program();\n    \n    if( this.tokens.length ){\n        this.throwError( `Unexpected token ${ this.tokens[ 0 ] } remaining` );\n    }\n    \n    return program;\n};\n\nBuilder.prototype.callExpression = function(){\n    const args = this.list( '(' );\n    this.consume( '(' );\n    const callee = this.expression();\n    \n    //console.log( 'CALL EXPRESSION' );\n    //console.log( '- CALLEE', callee );\n    //console.log( '- ARGUMENTS', args, args.length );\n    \n    return new CallExpression( callee, args );\n};\n\nBuilder.prototype.consume = function( expected ){\n    if( !this.tokens.length ){\n        this.throwError( 'Unexpected end of expression' );\n    }\n    \n    const token = this.expect( expected );\n    \n    if( !token ){\n        this.throwError( `Unexpected token ${ token.value } consumed` );\n    }\n    \n    return token;\n};\n\nBuilder.prototype.expect = function( first, second, third, fourth ){\n    const token = this.peek( first, second, third, fourth );\n    \n    if( token ){\n        this.tokens.pop();\n        return token;\n    }\n    \n    return undefined;\n};\n\nBuilder.prototype.expression = function(){\n    let expression = null,\n        list;\n    \n    if( this.peek() ){\n        if( this.expect( ']' ) ){\n            list = this.list( '[' );\n            if( this.tokens.length === 1 ){\n                expression = new ArrayExpression( list );\n                this.consume( '[' );\n            } else if( list.length > 1 ){\n                expression = new SequenceExpression( list );\n            } else {\n                expression = list[ 0 ];\n            }\n        } else if( this.peek().is( 'identifier' ) ){\n            expression = this.identifier();\n            \n            // Implied member expression\n            if( this.peek() && this.peek().is( 'punctuator' ) ){\n                if( this.peek( ')' ) || this.peek( ']' ) ){\n                    expression = this.memberExpression( expression, false );\n                }\n            }\n        } else if( this.peek().is( 'literal' ) ){\n            expression = this.literal();\n        }\n        \n        let next;\n        \n        while( ( next = this.expect( ')', '[', '.' ) ) ){\n            if( next.value === ')' ){\n                expression = this.callExpression();\n            } else if( next.value === '[' ){\n                expression = this.memberExpression( expression, true );\n            } else if( next.value === '.' ){\n                expression = this.memberExpression( expression, false );\n            } else {\n                this.throwError( `Unexpected token ${ next }` );\n            }\n        }\n    }\n    \n    return expression;\n};\n\nBuilder.prototype.expressionStatement = function(){\n    return new ExpressionStatement( this.expression() );\n};\n\nBuilder.prototype.identifier = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'identifier' ) ){\n        this.throwError( 'Identifier expected' );\n    }\n    \n    return new Identifier( token.value );\n};\n\nBuilder.prototype.literal = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'literal' ) ){\n        this.throwError( 'Literal expected' );\n    }\n    \n    const value = token.value,\n    \n        literal = value[ 0 ] === '\"' || value[ 0 ] === \"'\" ?\n            // String Literal\n            value.substring( 1, value.length - 1 ) :\n            // Numeric Literal\n            parseFloat( value );\n    \n    return new Literal( literal );\n};\n\nBuilder.prototype.list = function( terminator ){\n    const list = [];\n    \n    if( this.peek().value !== terminator ){\n        do {\n            if( this.peek( terminator ) ){\n                break;\n            }\n            list.unshift( this.literal() );\n        } while( this.expect( ',' ) );\n    }\n    \n    return list;\n};\n\nBuilder.prototype.memberExpression = function( property, computed ){\n    const object = this.expression();\n    \n    //console.log( 'MEMBER EXPRESSION' );\n    //console.log( '- OBJECT', object );\n    //console.log( '- PROPERTY', property );\n    //console.log( '- COMPUTED', computed );\n    \n    return new MemberExpression( object, property, computed );\n};\n\nBuilder.prototype.peek = function( first, second, third, fourth ){\n    const length = this.tokens.length;\n    return length ?\n        this.peekAt( length - 1, first, second, third, fourth ) :\n        undefined;\n};\n\nBuilder.prototype.peekAt = function( index, first, second, third, fourth ){\n    if( typeof index === 'number' ){\n        const token = this.tokens[ index ],\n            value = token.value;\n        \n        if( value === first || value === second || value === third || value === fourth || !arguments.length || ( !first && !second && !third && !fourth ) ){\n            return token;\n        }\n    }\n    \n    return undefined;\n};\n\nBuilder.prototype.program = function(){\n    const body = [];\n    \n    while( true ){\n        if( this.tokens.length ){\n            body.push( this.expressionStatement() );\n        } else {\n            return new Program( body );\n        }\n    }\n};\n\n/*\nBuilder.prototype.punctuator = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'punctuator' ) ){\n        this.throwError( 'Punctuator expected' );\n    }\n    \n    return new Punctuator( token.value );\n};\n*/\n\nBuilder.prototype.sequenceExpression = function(){\n    const args = this.bracketList();\n    return new SequenceExpression( args );\n};\n\nBuilder.prototype.throwError = function( message ){\n    throw new SyntaxError( message );\n};\n\nexport { Builder as default };","'use strict';\n\nexport default function forEach( arrayLike, callback ){\n    let index = 0,\n        length = arrayLike.length,\n        item;\n    \n    for( ; index < length; index++ ){\n        item = arrayLike[ index ];\n        callback( item );\n    }\n}","'use strict';\n\nimport forEach from './forEach';\nimport Null from './null';\n\nconst noop = function(){},\n\n    /**\n     * @namespace\n     */\n    interpret = new Null();\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.ArrayExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.elements, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'ARRAY EXPRESSION' );\n        \n        let result = [];\n        \n        forEach( args, function( arg ){\n            result.push( base[ arg( base, value ) ] );\n        } );\n        \n        if( result.length === 1 ){\n            result = result[ 0 ];\n        }\n        \n        //console.log( '- ARRAY RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.CallExpression = function( interpreter, node, context ){\n    const args = [];\n            \n    forEach( node.arguments, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    const right = interpreter.recurse( node.callee, true );\n    \n    return function( base, value ){\n        //console.log( 'CALL EXPRESSION' );\n        const rhs = right( base, value );\n        let result;\n        \n        if( typeof rhs.value === 'function' ){\n            const values = args.map( function( arg ){\n                return arg( base, value );\n            } );\n            result = rhs.value.apply( rhs.context, values );\n        } else if( typeof value !== 'undefined' ){\n            throw new Error( 'cannot create functions' );\n        }\n        \n        //console.log( '- CALL RESULT', result );\n        \n        return context ?\n            { value: result }:\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Identifier = function( interpreter, node, context ){\n    const name = node.name;\n    return function( base, value ){\n        //console.log( 'IDENTIFIER' );\n        let result;\n        \n        if( typeof base !== 'undefined' ){\n            if( typeof value !== 'undefined' && !( name in base ) ){\n                base[ name ] = new Null();\n            }\n            \n            result = base[ name ];\n        }\n        \n        //console.log( '- NAME', name );\n        //console.log( '- IDENTIFIER RESULT', result );\n        \n        return context ?\n            { context: base, name: name, value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Literal = function( interpreter, node, context ){\n    const value = node.value;\n    return function(){\n        //console.log( 'LITERAL' );\n        //console.log( '- LITERAL RESULT', value );\n        return context ?\n            { context: undefined, name: undefined, value: value } :\n            value;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.MemberExpression = function( interpreter, node, context ){\n    const left = interpreter.recurse( node.object, false );\n    \n    let fn, lhs, result, rhs, right;\n    \n    if( node.computed ){\n        right = interpreter.recurse( node.property, false );\n        fn = function( base, value ){\n            //console.log( 'COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                rhs = right( base, value );\n                \n                if( typeof value !== 'undefined' && !( rhs in lhs ) ){\n                    lhs[ rhs ] = new Null();\n                }\n                \n                //console.log( '- COMPUTED RHS', rhs );\n                \n                if( Array.isArray( lhs ) ){\n                    // Sequence expression\n                    if( Array.isArray( rhs ) ){\n                        result = rhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    // Literal expression\n                    } else if( lhs.length === 1 ){\n                        result = lhs[ 0 ];\n                    // Array expression\n                    } else {\n                        result = lhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    }\n                } else {\n                    result = lhs[ rhs ];\n                }\n            }\n            \n            //console.log( '- COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: rhs, value: result } :\n                result;\n        };\n    } else {\n        right = node.property.name;\n        fn = function( base, value ){\n            //console.log( 'NON-COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- NON-COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                if( typeof value !== 'undefined' && !( right in lhs ) ){\n                    lhs[ right ] = value || new Null();\n                }\n                \n                //console.log( '- NON-COMPUTED RIGHT', right );\n                \n                if( Array.isArray( lhs ) ){\n                    result = lhs.map( function( item ){\n                       return item[ right ];\n                    } );\n                } else {\n                    result = lhs[ right ];\n                }\n            }\n            \n            //console.log( '- NON-COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: right, value: result } :\n                result;\n        };\n    }\n    \n    return fn;\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.SequenceExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.expressions, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'SEQUENCE EXPRESSION' );\n        \n        const result = [];\n        \n        forEach( args, function( arg ){\n            result.push( arg( base, value ) );\n        } );\n        \n        //console.log( '- SEQUENCE RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @class Interpreter\n * @extends Null\n * @param {Builder} builder\n */\nfunction Interpreter( builder ){\n    if( !arguments.length ){\n        throw new TypeError( 'builder cannot be undefined' );\n    }\n    \n    this.builder = builder;\n}\n\nInterpreter.prototype = new Null();\n\nInterpreter.prototype.constructor = Interpreter;\n\n/**\n * @function\n * @param {external:string} expression\n */\nInterpreter.prototype.compile = function( expression ){\n    const ast = this.builder.build( expression ),\n        body = ast.body,\n        interpreter = this;\n    \n    let fn;\n    \n    interpreter.expression = expression;\n    \n    switch( body.length ){\n        case 0:\n            fn = noop;\n            break;\n        case 1:\n            fn = interpreter.recurse( body[ 0 ].expression, false );\n            break;\n        default:\n            const expressions = [];\n            forEach( body, function( statement ){\n                expressions.push( interpreter.recurse( statement.expression, false ) );\n            } );\n            fn = function( base, value ){\n                let lastValue;\n                \n                forEach( expressions, function( expression ){\n                    lastValue = expression( base, value );\n                } );\n                \n                return lastValue;\n            };\n            break;\n    }\n    \n    return fn;\n};\n\nInterpreter.prototype.recurse = function( node, context ){\n    ////console.log( 'RECURSE', node );\n    \n    if( !( node.type in interpret ) ){\n        this.throwError( `Unknown node type ${ node.type }` );\n    }\n    \n    return interpret[ node.type ]( this, node, context );\n};\n\nInterpreter.prototype.throwError = function( message ){\n    throw new Error( message );\n};\n\nexport { Interpreter as default };","'use strict';\n\nimport Null from './null';\nimport Lexer from './lexer';\nimport Builder from './builder';\nimport Interpreter from './interpreter';\n\nconst lexer = new Lexer(),\n    builder = new Builder( lexer ),\n    intrepreter = new Interpreter( builder );\n\n/**\n * @class KeyPathExp\n * @extends Null\n * @param {external:string} pattern\n * @param {external:string} flags\n */\nfunction KeyPathExp( pattern, flags ){\n    Object.defineProperty( this, 'value', {\n        value: intrepreter.compile( pattern ),\n        configurable: false,\n        enumerable: false,\n        writable: false\n    } );\n}\n\nKeyPathExp.prototype = new Null();\n\nKeyPathExp.prototype.constructor = KeyPathExp;\n\nKeyPathExp.prototype.get = function( target ){\n    return this.value( target, false );\n};\n\nKeyPathExp.prototype.set = function( target, value ){\n    return this.value( target, true, value );\n};\n\nexport { KeyPathExp as default };"],"names":["Null","prototype","Object","create","constructor","id","nextId","Token","type","value","TypeError","length","equals","token","valueOf","is","toJSON","json","toString","String","Identifier","call","Literal","Punctuator","LexerError","message","SyntaxError","Lexer","buffer","lex","text","index","tokens","word","char","isIdentifier","read","isNumeric","push","isPunctuator","isQuote","quote","isWhitespace","throwError","until","start","slice","map","Node","node","Statement","statementType","Expression","expressionType","Program","body","Array","isArray","ArrayExpression","elements","element","ExpressionStatement","expression","CallExpression","callee","args","arguments","MemberExpression","object","property","computed","name","split","indexOf","RegExp","SequenceExpression","expressions","Builder","lexer","arrayExpression","bracketList","build","program","callExpression","list","consume","expected","expect","first","second","third","fourth","peek","pop","undefined","identifier","memberExpression","literal","next","expressionStatement","substring","terminator","unshift","peekAt","sequenceExpression","forEach","arrayLike","callback","item","noop","interpret","interpreter","context","expr","recurse","base","result","arg","right","rhs","values","apply","Error","left","fn","lhs","Interpreter","builder","compile","ast","statement","lastValue","intrepreter","KeyPathExp","pattern","flags","defineProperty","get","target","set"],"mappings":"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","sourceRoot":"/source/"}