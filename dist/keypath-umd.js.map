{"version":3,"file":"keypath-umd.js","sources":["null.js","uuid.js","lexer/token.js","lexer.js","builder/node.js","builder.js","forEach.js","interpreter.js","keypath.js"],"sourcesContent":["'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nexport default function Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;","'use strict';\n\nlet id = 0;\n\nexport default function nextId(){\n    return ++id;\n}","'use strict';\n\nimport Null from '../null';\nimport nextId from '../uuid';\n\n/**\n * @class Token\n * @extends Null\n * @param {external:string} type The type of the token\n * @param {*} value The value of the token\n * @throws {external:TypeError} If `type` is not a string\n * @throws {external:TypeError} If `value` is undefined.\n */\nfunction Token( type, value ){\n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    if( typeof value === 'undefined' ){\n        throw new TypeError( 'value cannot be undefined' );\n    }\n    \n    this.id = nextId();\n    this.type = type;\n    this.value = value;\n    this.length = value.length;\n}\n\nToken.prototype = new Null();\n\nToken.prototype.constructor = Token;\n\nToken.prototype.equals = function( token ){\n    return token instanceof Token && this.valueOf() === token.valueOf();\n};\n\n/**\n * @function\n * @param {external:string} type\n * @returns {external:boolean} Whether or not the token is the `type` provided.\n */\nToken.prototype.is = function( type ){\n    return this.type === type;\n};\n\nToken.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.type = this.type;\n    json.value = this.value;\n    \n    return json;\n};\n\nToken.prototype.toString = function(){\n    return String( this.value );\n};\n\nToken.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Token as default };\n\nexport function Identifier( value ){\n    Token.call( this, 'identifier', value );\n}\n\nIdentifier.prototype = Object.create( Token.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\nexport function Literal( value ){\n    Token.call( this, 'literal', value );\n}\n\nLiteral.prototype = Object.create( Token.prototype );\n\nLiteral.prototype.constructor = Literal;\n\nexport function Punctuator( value ){\n    Token.call( this, 'punctuator', value );\n}\n\nPunctuator.prototype = Object.create( Token.prototype );\n\nPunctuator.prototype.constructor = Punctuator;","'use strict';\n\nimport Null from './null';\nimport { Identifier, Literal, Punctuator } from './lexer/token';\n\n/**\n * @class LexerError\n * @extends SyntaxError\n * @param {external:string} message The error message\n */\nfunction LexerError( message ){\n    SyntaxError.call( this, message );    \n}\n\nLexerError.prototype = Object.create( SyntaxError.prototype );\n\n/**\n * @class Lexer\n * @extends Null\n */\nexport default function Lexer(){\n    this.buffer = '';\n}\n\nLexer.prototype = new Null();\n\nLexer.prototype.constructor = Lexer;\n\nLexer.prototype.lex = function( text ){\n    this.buffer = text;\n    this.index = 0;\n    this.tokens = [];\n    \n    const length = this.buffer.length;\n    let word = '',\n        char;\n    \n    while( this.index < length ){\n        char = this.buffer[ this.index ];\n        \n        // Identifier\n        if( this.isIdentifier( char ) ){\n            word = this.read( function( char ){\n                return !this.isIdentifier( char ) && !this.isNumeric( char );\n            } );\n            \n            this.tokens.push( new Identifier( word ) );\n        \n        // Punctuator\n        } else if( this.isPunctuator( char ) ){\n            this.tokens.push( new Punctuator( char ) );\n            this.index++;\n        \n        // Quoted String\n        } else if( this.isQuote( char ) ){\n            let quote = char;\n            \n            this.index++;\n            \n            word = this.read( function( char ){\n                return char === quote;\n            } );\n            \n            this.tokens.push( new Literal( `${ quote }${ word }${ quote }` ) );\n            \n            this.index++;\n        \n        // Numeric\n        } else if( this.isNumeric( char ) ){\n            word = this.read( function( char ){\n                return !this.isNumeric( char );\n            } );\n            \n            this.tokens.push( new Literal( word ) );\n        \n        // Whitespace\n        } else if( this.isWhitespace( char ) ){\n            this.index++;\n        \n        // Error\n        } else {\n            this.throwError( `\"${ char }\" is an invalid character` );\n        }\n        \n        word = '';\n    }\n    \n    return this.tokens;\n};\n\nLexer.prototype.isIdentifier = function( char ){\n    return 'a' <= char && char <= 'z' || 'A' <= char && char <= 'Z' || '_' === char || char === '$';\n};\n\nLexer.prototype.isPunctuator = function( char ){\n    return char === '.' || char === '(' || char === ')' || char === '[' || char === ']' || char === ',' || char === '%';\n};\n\nLexer.prototype.isWhitespace = function( char ){\n    return char === ' ' || char === '\\r' || char === '\\t' || char === '\\n' || char === '\\v' || char === '\\u00A0';\n};\n\nLexer.prototype.isQuote = function( char ){\n    return char === '\"' || char === \"'\";\n};\n\nLexer.prototype.isNumeric = function( char ){\n    return '0' <= char && char <= '9';\n};\n\nLexer.prototype.read = function( until ){\n    let start = this.index,\n        char;\n    \n    while( this.index < this.buffer.length ){\n        char = this.buffer[ this.index ];\n        \n        if( until.call( this, char ) ){\n            break;\n        }\n        \n        this.index++;\n    }\n    \n    return this.buffer.slice( start, this.index );\n};\n\nLexer.prototype.throwError = function( message ){\n    throw new LexerError( message );\n};\n\nLexer.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.buffer = this.buffer;\n    json.tokens = this.tokens.map( function( token ){\n        return token.toJSON();\n    } );\n    \n    return json;\n};\n","'use strict';\n\nimport Null from '../null';\nimport nextId from '../uuid';\n\n/**\n * @class Node\n * @extends Null\n * @param {external:string} type The type of node\n */\nfunction Node( type ){\n    \n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    this.id = nextId();\n    this.type = type;\n}\n\nNode.prototype = new Null();\n\nNode.prototype.constructor = Node;\n\nNode.prototype.equals = function( node ){\n    return node instanceof Node && this.valueOf() === node.valueOf();\n};\n\nNode.prototype.is = function( type ){\n    return this.type === type;\n};\n\nNode.prototype.toJSON = function(){\n    const json = new Null();\n    \n    json.type = this.type;\n    \n    return json;\n};\n\nNode.prototype.toString = function(){\n    return String( this.type );\n};\n\nNode.prototype.valueOf = function(){\n    return this.id;\n};\n\nexport { Node as default };\n\nfunction Statement( statementType ){\n    Node.call( this, statementType );\n}\n\nStatement.prototype = Object.create( Node.prototype );\n\nStatement.prototype.constructor = Statement;\n\nfunction Expression( expressionType ){\n    Node.call( this, expressionType );\n}\n\nExpression.prototype = Object.create( Node.prototype );\n\nExpression.prototype.constructor = Expression;\n\nexport function Program( body ){\n    Node.call( this, 'Program' );\n    \n    if( !Array.isArray( body ) ){\n        throw new TypeError( 'body must be an array' );\n    }\n    \n    this.body = body || [];\n}\n\nProgram.prototype = Object.create( Node.prototype );\n\nProgram.prototype.constructor = Program;\n\nProgram.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.body = this.body.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\nexport function ArrayExpression( elements ){\n    Expression.call( this, 'ArrayExpression' );\n    \n    if( !( Array.isArray( elements ) ) ){\n        throw new TypeError( 'elements must be a list of expressions' );\n    }\n    \n    this.elements = elements;\n}\n\nArrayExpression.prototype = Object.create( Expression.prototype );\n\nArrayExpression.prototype.constructor = ArrayExpression;\n\nArrayExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.elements = this.elements.map( function( element ){\n        return element.toJSON();\n    } );\n    \n    return json;\n};\n\nexport function ExpressionStatement( expression ){\n    Statement.call( this, 'ExpressionStatement' );\n    \n    if( !( expression instanceof Expression ) ){\n        throw new TypeError( 'argument must be an expression' );\n    }\n    \n    this.expression = expression;\n}\n\nExpressionStatement.prototype = Object.create( Statement.prototype );\n\nExpressionStatement.prototype.constructor = ExpressionStatement;\n\nExpressionStatement.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expression = this.expression.toJSON();\n    \n    return json;\n};\n\nexport function CallExpression( callee, args ){\n    Expression.call( this, 'CallExpression' );\n    \n    if( !Array.isArray( args ) ){\n        throw new TypeError( 'arguments must be an array' );\n    }\n    \n    this.callee = callee;\n    this.arguments = args;\n}\n\nCallExpression.prototype = Object.create( Expression.prototype );\n\nCallExpression.prototype.constructor = CallExpression;\n\nCallExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.callee    = this.callee.toJSON();\n    json.arguments = this.arguments.map( ( node ) => node.toJSON() );\n    \n    return json;\n};\n\nexport function MemberExpression( object, property, computed ){\n    Expression.call( this, 'MemberExpression' );\n    \n    if( computed ){\n        if( !( property instanceof Expression ) ){\n            throw new TypeError( 'property must be an expression when computed is true' );\n        }\n    } else {\n        if( !( property instanceof Identifier ) ){\n            throw new TypeError( 'property must be an identifier when computed is false' );\n        }\n    }\n    \n    this.object = object;\n    this.property = property;\n    this.computed = computed || false;\n}\n\nMemberExpression.prototype = Object.create( Expression.prototype );\n\nMemberExpression.prototype.constructor = MemberExpression;\n\nMemberExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.object   = this.object.toJSON();\n    json.property = this.property.toJSON();\n    json.computed = this.computed;\n    \n    return json;\n};\n\nexport function Identifier( name ){\n    Expression.call( this, 'Identifier' );\n    \n    if( typeof name !== 'string' ){\n        throw new TypeError( 'name must be a string' );\n    }\n    \n    this.name = name;\n}\n\nIdentifier.prototype = Object.create( Expression.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\nIdentifier.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.name = this.name;\n    \n    return json;\n};\n\nexport function Literal( value ){\n    Expression.call( this, 'Literal' );\n    \n    const type = typeof value;\n    \n    if( 'boolean number string'.split( ' ' ).indexOf( type ) === -1 && value !== null && !( value instanceof RegExp ) ){\n        throw new TypeError( 'value must be a boolean, number, string, null, or instance of RegExp' );\n    }\n    \n    this.value = value;\n}\n\nLiteral.prototype = Object.create( Expression.prototype );\n\nLiteral.prototype.constructor = Literal;\n\nLiteral.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};\n\nexport function SequenceExpression( expressions ){\n    Expression.call( this, 'SequenceExpression' );\n    \n    if( !( Array.isArray( expressions ) ) ){\n        throw new TypeError( 'expressions must be a list of expressions' );\n    }\n    \n    this.expressions = expressions;\n}\n\nSequenceExpression.prototype = Object.create( Expression.prototype );\n\nSequenceExpression.prototype.constructor = SequenceExpression;\n\nSequenceExpression.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.expressions = this.expressions.map( function( expression ){\n        return expression.toJSON();\n    } );\n    \n    return json;\n};\n\nexport function Punctuator( value ){\n    Node.call( this, 'Punctuator' );\n    \n    if( typeof value !== 'string' ){\n        throw new TypeError( 'value must be a string' );\n    }\n    \n    this.value = value;\n}\n\nPunctuator.prototype = Object.create( Node.prototype );\n\nPunctuator.prototype.constructor = Punctuator;\n\nPunctuator.prototype.toJSON = function(){\n    const json = Node.prototype.toJSON.call( this );\n    \n    json.value = this.value;\n    \n    return json;\n};","'use strict';\n\nimport Null from './null';\nimport { ArrayExpression, CallExpression, ExpressionStatement, Identifier, Literal, MemberExpression, Program, SequenceExpression /*, Punctuator*/ } from './builder/node';\n\n/**\n * @class Builder\n * @extends Null\n * @param {Lexer} lexer\n */\nfunction Builder( lexer ){\n    if( !arguments.length ){\n        throw new TypeError( 'lexer must be provided' );\n    }\n    \n    this.lexer = lexer;\n}\n\nBuilder.prototype = new Null();\n\nBuilder.prototype.constructor = Builder;\n\n/**\n * @function\n * @param {external:string} text\n * @returns {Program} The built abstract syntax tree\n */\nBuilder.prototype.build = function( text ){\n    this.buffer = text;\n    this.tokens = this.lexer.lex( text );\n    \n    const program = this.program();\n    \n    if( this.tokens.length ){\n        this.throwError( `Unexpected token ${ this.tokens[ 0 ] } remaining` );\n    }\n    \n    return program;\n};\n\n/**\n * @function\n * @returns {CallExpression} The call expression node\n */\nBuilder.prototype.callExpression = function(){\n    const args = this.list( '(' );\n    this.consume( '(' );\n    const callee = this.expression();\n    \n    //console.log( 'CALL EXPRESSION' );\n    //console.log( '- CALLEE', callee );\n    //console.log( '- ARGUMENTS', args, args.length );\n    \n    return new CallExpression( callee, args );\n};\n\n/**\n * @function\n * @param {external:string} [expected]\n * @returns {Token} The next token in the list\n */\nBuilder.prototype.consume = function( expected ){\n    if( !this.tokens.length ){\n        this.throwError( 'Unexpected end of expression' );\n    }\n    \n    const token = this.expect( expected );\n    \n    if( !token ){\n        this.throwError( `Unexpected token ${ token.value } consumed` );\n    }\n    \n    return token;\n};\n\n/**\n * @function\n * @param {external:string} [first]\n * @param {external:string} [second]\n * @param {external:string} [third]\n * @param {external:string} [fourth]\n * @returns {Token} The next token in the list\n */\nBuilder.prototype.expect = function( first, second, third, fourth ){\n    const token = this.peek( first, second, third, fourth );\n    \n    if( token ){\n        this.tokens.pop();\n        return token;\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Expression} An expression node\n */\nBuilder.prototype.expression = function(){\n    let expression = null,\n        list;\n    \n    if( this.peek() ){\n        if( this.expect( ']' ) ){\n            list = this.list( '[' );\n            if( this.tokens.length === 1 ){\n                expression = new ArrayExpression( list );\n                this.consume( '[' );\n            } else if( list.length > 1 ){\n                expression = new SequenceExpression( list );\n            } else {\n                expression = list[ 0 ];\n            }\n        } else if( this.peek().is( 'identifier' ) ){\n            expression = this.identifier();\n            \n            // Implied member expression\n            if( this.peek() && this.peek().is( 'punctuator' ) ){\n                if( this.peek( ')' ) || this.peek( ']' ) ){\n                    expression = this.memberExpression( expression, false );\n                }\n            }\n        } else if( this.peek().is( 'literal' ) ){\n            expression = this.literal();\n        }\n        \n        let next;\n        \n        while( ( next = this.expect( ')', '[', '.' ) ) ){\n            if( next.value === ')' ){\n                expression = this.callExpression();\n            } else if( next.value === '[' ){\n                expression = this.memberExpression( expression, true );\n            } else if( next.value === '.' ){\n                expression = this.memberExpression( expression, false );\n            } else {\n                this.throwError( `Unexpected token ${ next }` );\n            }\n        }\n    }\n    \n    return expression;\n};\n\nBuilder.prototype.expressionStatement = function(){\n    return new ExpressionStatement( this.expression() );\n};\n\nBuilder.prototype.identifier = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'identifier' ) ){\n        this.throwError( 'Identifier expected' );\n    }\n    \n    return new Identifier( token.value );\n};\n\n/**\n * @function\n * @returns {Literal} The literal node\n */\nBuilder.prototype.literal = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'literal' ) ){\n        this.throwError( 'Literal expected' );\n    }\n    \n    const value = token.value,\n    \n        literal = value[ 0 ] === '\"' || value[ 0 ] === \"'\" ?\n            // String Literal\n            value.substring( 1, value.length - 1 ) :\n            // Numeric Literal\n            parseFloat( value );\n    \n    return new Literal( literal );\n};\n\n/**\n * @function\n * @param {external:string} terminator\n * @returns {external:Array<Literal>} The list of literals\n */\nBuilder.prototype.list = function( terminator ){\n    const list = [];\n    \n    if( this.peek().value !== terminator ){\n        do {\n            list.unshift( this.literal() );\n        } while( this.expect( ',' ) );\n    }\n    \n    return list;\n};\n\n/**\n * @function\n * @param {Expression} property The expression assigned to the property of the member expression\n * @param {external:boolean} computed Whether or not the member expression is computed\n * @returns {MemberExpression} The member expression\n */\nBuilder.prototype.memberExpression = function( property, computed ){\n    const object = this.expression();\n    \n    //console.log( 'MEMBER EXPRESSION' );\n    //console.log( '- OBJECT', object );\n    //console.log( '- PROPERTY', property );\n    //console.log( '- COMPUTED', computed );\n    \n    return new MemberExpression( object, property, computed );\n};\n\nBuilder.prototype.peek = function( first, second, third, fourth ){\n    const length = this.tokens.length;\n    return length ?\n        this.peekAt( length - 1, first, second, third, fourth ) :\n        undefined;\n};\n\nBuilder.prototype.peekAt = function( index, first, second, third, fourth ){\n    if( typeof index === 'number' ){\n        const token = this.tokens[ index ],\n            value = token.value;\n        \n        if( value === first || value === second || value === third || value === fourth || !arguments.length || ( !first && !second && !third && !fourth ) ){\n            return token;\n        }\n    }\n    \n    return undefined;\n};\n\n/**\n * @function\n * @returns {Program} A program node\n */\nBuilder.prototype.program = function(){\n    const body = [];\n    \n    while( true ){\n        if( this.tokens.length ){\n            body.push( this.expressionStatement() );\n        } else {\n            return new Program( body );\n        }\n    }\n};\n\n/*\nBuilder.prototype.punctuator = function(){\n    const token = this.consume();\n    \n    if( !( token.type === 'punctuator' ) ){\n        this.throwError( 'Punctuator expected' );\n    }\n    \n    return new Punctuator( token.value );\n};\n*/\n\n/**\n * @function\n * @param {external:string} message The error message\n * @throws {external:SyntaxError} When it executes\n */\nBuilder.prototype.throwError = function( message ){\n    throw new SyntaxError( message );\n};\n\nexport { Builder as default };","'use strict';\n\nexport default function forEach( arrayLike, callback ){\n    let index = 0,\n        length = arrayLike.length,\n        item;\n    \n    for( ; index < length; index++ ){\n        item = arrayLike[ index ];\n        callback( item );\n    }\n}","'use strict';\n\nimport forEach from './forEach';\nimport Null from './null';\n\nconst noop = function(){},\n\n    /**\n     * @namespace\n     */\n    interpret = new Null();\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.ArrayExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.elements, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'ARRAY EXPRESSION' );\n        \n        let result = [];\n        \n        forEach( args, function( arg ){\n            result.push( base[ arg( base, value ) ] );\n        } );\n        \n        if( result.length === 1 ){\n            result = result[ 0 ];\n        }\n        \n        //console.log( '- ARRAY RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.CallExpression = function( interpreter, node, context ){\n    const args = [];\n            \n    forEach( node.arguments, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    const right = interpreter.recurse( node.callee, true );\n    \n    return function( base, value ){\n        //console.log( 'CALL EXPRESSION' );\n        const rhs = right( base, value );\n        let result;\n        \n        if( typeof rhs.value === 'function' ){\n            const values = args.map( function( arg ){\n                return arg( base, value );\n            } );\n            result = rhs.value.apply( rhs.context, values );\n        } else if( typeof value !== 'undefined' ){\n            throw new Error( 'cannot create functions' );\n        }\n        \n        //console.log( '- CALL RESULT', result );\n        \n        return context ?\n            { value: result }:\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Identifier = function( interpreter, node, context ){\n    const name = node.name;\n    return function( base, value ){\n        //console.log( 'IDENTIFIER' );\n        let result;\n        \n        if( typeof base !== 'undefined' ){\n            if( typeof value !== 'undefined' && !( name in base ) ){\n                base[ name ] = new Null();\n            }\n            \n            result = base[ name ];\n        }\n        \n        //console.log( '- NAME', name );\n        //console.log( '- IDENTIFIER RESULT', result );\n        \n        return context ?\n            { context: base, name: name, value: result } :\n            result;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.Literal = function( interpreter, node, context ){\n    const value = node.value;\n    return function(){\n        //console.log( 'LITERAL' );\n        //console.log( '- LITERAL RESULT', value );\n        return context ?\n            { context: undefined, name: undefined, value: value } :\n            value;\n    };\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.MemberExpression = function( interpreter, node, context ){\n    const left = interpreter.recurse( node.object, false );\n    \n    let fn, lhs, result, rhs, right;\n    \n    if( node.computed ){\n        right = interpreter.recurse( node.property, false );\n        fn = function( base, value ){\n            //console.log( 'COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                rhs = right( base, value );\n                \n                if( typeof value !== 'undefined' && !( rhs in lhs ) ){\n                    lhs[ rhs ] = new Null();\n                }\n                \n                //console.log( '- COMPUTED RHS', rhs );\n                \n                if( Array.isArray( lhs ) ){\n                    // Sequence expression\n                    if( Array.isArray( rhs ) ){\n                        result = rhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    // Literal expression\n                    } else if( lhs.length === 1 ){\n                        result = lhs[ 0 ];\n                    // Array expression\n                    } else {\n                        result = lhs.map( function( index ){\n                            return lhs[ index ];\n                        } );\n                    }\n                } else {\n                    result = lhs[ rhs ];\n                }\n            }\n            \n            //console.log( '- COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: rhs, value: result } :\n                result;\n        };\n    } else {\n        right = node.property.name;\n        fn = function( base, value ){\n            //console.log( 'NON-COMPUTED MEMBER' );\n            lhs = left( base, value );\n            \n            //console.log( '- NON-COMPUTED LHS', lhs );\n            \n            if( typeof lhs !== 'undefined' ){\n                if( typeof value !== 'undefined' && !( right in lhs ) ){\n                    lhs[ right ] = value || new Null();\n                }\n                \n                //console.log( '- NON-COMPUTED RIGHT', right );\n                \n                if( Array.isArray( lhs ) ){\n                    result = lhs.map( function( item ){\n                       return item[ right ];\n                    } );\n                } else {\n                    result = lhs[ right ];\n                }\n            }\n            \n            //console.log( '- NON-COMPUTED RESULT', result );\n            \n            return context ?\n                { context: lhs, name: right, value: result } :\n                result;\n        };\n    }\n    \n    return fn;\n};\n\n/**\n * @function\n * @param {Interpreter} interpeter\n * @param {Node} node\n * @param {external:boolean} context\n * @returns {external:Function} The interpreted expression.\n */\ninterpret.SequenceExpression = function( interpreter, node, context ){\n    const args = [];\n    \n    forEach( node.expressions, function( expr ){\n        args.push( interpreter.recurse( expr, false ) );\n    } );\n    \n    return function( base, value ){\n        //console.log( 'SEQUENCE EXPRESSION' );\n        \n        const result = [];\n        \n        forEach( args, function( arg ){\n            result.push( arg( base, value ) );\n        } );\n        \n        //console.log( '- SEQUENCE RESULT', result );\n        \n        return context ?\n            { value: result } :\n            result;\n    };\n};\n\n/**\n * @class Interpreter\n * @extends Null\n * @param {Builder} builder\n */\nfunction Interpreter( builder ){\n    if( !arguments.length ){\n        throw new TypeError( 'builder cannot be undefined' );\n    }\n    \n    this.builder = builder;\n}\n\nInterpreter.prototype = new Null();\n\nInterpreter.prototype.constructor = Interpreter;\n\n/**\n * @function\n * @param {external:string} expression\n */\nInterpreter.prototype.compile = function( expression ){\n    const ast = this.builder.build( expression ),\n        body = ast.body,\n        interpreter = this;\n    \n    let fn;\n    \n    interpreter.expression = expression;\n    \n    switch( body.length ){\n        case 0:\n            fn = noop;\n            break;\n        case 1:\n            fn = interpreter.recurse( body[ 0 ].expression, false );\n            break;\n        default:\n            const expressions = [];\n            forEach( body, function( statement ){\n                expressions.push( interpreter.recurse( statement.expression, false ) );\n            } );\n            fn = function( base, value ){\n                let lastValue;\n                \n                forEach( expressions, function( expression ){\n                    lastValue = expression( base, value );\n                } );\n                \n                return lastValue;\n            };\n            break;\n    }\n    \n    return fn;\n};\n\nInterpreter.prototype.recurse = function( node, context ){\n    ////console.log( 'RECURSE', node );\n    \n    if( !( node.type in interpret ) ){\n        this.throwError( `Unknown node type ${ node.type }` );\n    }\n    \n    return interpret[ node.type ]( this, node, context );\n};\n\nInterpreter.prototype.throwError = function( message ){\n    throw new Error( message );\n};\n\nexport { Interpreter as default };","'use strict';\n\nimport Null from './null';\nimport Lexer from './lexer';\nimport Builder from './builder';\nimport Interpreter from './interpreter';\n\nconst lexer = new Lexer(),\n    builder = new Builder( lexer ),\n    intrepreter = new Interpreter( builder );\n\n/**\n * @class KeyPathExp\n * @extends Null\n * @param {external:string} pattern\n * @param {external:string} flags\n */\nfunction KeyPathExp( pattern, flags ){\n    Object.defineProperty( this, 'value', {\n        value: intrepreter.compile( pattern ),\n        configurable: false,\n        enumerable: false,\n        writable: false\n    } );\n}\n\nKeyPathExp.prototype = new Null();\n\nKeyPathExp.prototype.constructor = KeyPathExp;\n\nKeyPathExp.prototype.get = function( target ){\n    return this.value( target, false );\n};\n\nKeyPathExp.prototype.set = function( target, value ){\n    return this.value( target, true, value );\n};\n\nexport { KeyPathExp as default };"],"names":["Identifier","Literal"],"mappings":"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","sourceRoot":"/source/"}