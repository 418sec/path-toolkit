{"version":3,"file":"lexer-umd.js","sources":["null.js","lexer/grammar.js","lexer/token.js","lexer.js"],"sourcesContent":["'use strict';\n\n/**\n * A \"clean\", empty container. Instantiating this is faster than explicitly calling `Object.create( null )`.\n * @class Null\n * @extends external:null\n */\nfunction Null(){}\nNull.prototype = Object.create( null );\nNull.prototype.constructor =  Null;\n\nexport { Null as default };","'use strict';\n\nimport Null from '../null';\n\nvar Grammar = new Null();\n\nGrammar.Identifier  = 'Identifier';\nGrammar.Literal     = 'Literal';\nGrammar.Punctuator  = 'Punctuator';\n\nexport { Grammar as default };","'use strict';\n\nimport Grammar from './grammar';\nimport Null from '../null';\n\nvar tokenId = 0;\n\n/**\n * @class Lexer~Token\n * @extends Null\n * @param {external:string} type The type of the token\n * @param {external:string} value The value of the token\n * @throws {external:TypeError} If `type` is not a string\n * @throws {external:TypeError} If `value` is not a string\n */\nfunction Token( type, value ){\n    if( typeof type !== 'string' ){\n        throw new TypeError( 'type must be a string' );\n    }\n    \n    if( typeof value !== 'string' ){\n        throw new TypeError( 'value must be a string' );\n    }\n    \n    /**\n     * @member {external:number} Lexer~Token#id\n     */\n    this.id = ++tokenId;\n    /**\n     * @member {external:string} Lexer~Token#type\n     */\n    this.type = type;\n    /**\n     * @member {external:string} Lexer~Token#value\n     */\n    this.value = value;\n    /**\n     * The length of the token value\n     * @member {external:number} Lexer~Token#length\n     */\n    this.length = value.length;\n}\n\nToken.prototype = new Null();\n\nToken.prototype.constructor = Token;\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the token\n */\nToken.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.type = this.type;\n    json.value = this.value;\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the token\n */\nToken.prototype.toString = function(){\n    return String( this.value );\n};\n\n/**\n * @class Lexer~Identifier\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Identifier( value ){\n    Token.call( this, Grammar.Identifier, value );\n}\n\nIdentifier.prototype = Object.create( Token.prototype );\n\nIdentifier.prototype.constructor = Identifier;\n\n/**\n * @class Lexer~Literal\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Literal( value ){\n    Token.call( this, Grammar.Literal, value );\n}\n\nLiteral.prototype = Object.create( Token.prototype );\n\nLiteral.prototype.constructor = Literal;\n\n/**\n * @class Lexer~Punctuator\n * @extends Lexer~Token\n * @param {external:string} value\n */\nexport function Punctuator( value ){\n    Token.call( this, Grammar.Punctuator, value );\n}\n\nPunctuator.prototype = Object.create( Token.prototype );\n\nPunctuator.prototype.constructor = Punctuator;\n\nexport { Token as default };","'use strict';\n\nimport Null from './null';\nimport { Identifier, Literal, Punctuator } from './lexer/token';\n\n/**\n * @function Lexer~isIdentifier\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is an identifier character\n */\nfunction isIdentifier( char ){\n    return 'a' <= char && char <= 'z' || 'A' <= char && char <= 'Z' || '_' === char || char === '$';\n}\n\n/**\n * @function Lexer~isNumeric\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a numeric character\n */\nfunction isNumeric( char ){\n    return '0' <= char && char <= '9';\n}\n\n/**\n * @function Lexer~isPunctuator\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a punctuator character\n */\nfunction isPunctuator( char ){\n    return char === '.' || char === '(' || char === ')' || char === '[' || char === ']' || char === ',' || char === '%';\n}\n\n/**\n * @function Lexer~isQuote\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a quote character\n */\nfunction isQuote( char ){\n    return char === '\"' || char === \"'\";\n}\n\n/**\n * @function Lexer~isWhitespace\n * @param {external:string} char\n * @returns {external:boolean} Whether or not the character is a whitespace character\n */\nfunction isWhitespace( char ){\n    return char === ' ' || char === '\\r' || char === '\\t' || char === '\\n' || char === '\\v' || char === '\\u00A0';\n}\n\n/**\n * @class Lexer~LexerError\n * @extends external:SyntaxError\n * @param {external:string} message The error message\n */\nfunction LexerError( message ){\n    SyntaxError.call( this, message );    \n}\n\nLexerError.prototype = Object.create( SyntaxError.prototype );\n\n/**\n * @class Lexer\n * @extends Null\n */\nfunction Lexer(){\n    this.buffer = '';\n}\n\nLexer.prototype = new Null();\n\nLexer.prototype.constructor = Lexer;\n\n/**\n * @function\n * @param {external:string} text\n */\nLexer.prototype.lex = function( text ){\n    /**\n     * @member {external:string}\n     * @default ''\n     */\n    this.buffer = text;\n    /**\n     * @member {external:number}\n     */\n    this.index = 0;\n    /**\n     * @member {Array<Lexer~Token>}\n     */\n    this.tokens = [];\n    \n    var length = this.buffer.length,\n        word = '',\n        char, quote;\n    \n    while( this.index < length ){\n        char = this.buffer[ this.index ];\n        \n        // Identifier\n        if( isIdentifier( char ) ){\n            word = this.read( function( char ){\n                return !isIdentifier( char ) && !isNumeric( char );\n            } );\n            \n            this.tokens.push( new Identifier( word ) );\n        \n        // Punctuator\n        } else if( isPunctuator( char ) ){\n            this.tokens.push( new Punctuator( char ) );\n            this.index++;\n        \n        // Quoted String\n        } else if( isQuote( char ) ){\n            quote = char;\n            \n            this.index++;\n            \n            word = this.read( function( char ){\n                return char === quote;\n            } );\n            \n            this.tokens.push( new Literal( quote + word + quote ) );\n            \n            this.index++;\n        \n        // Numeric\n        } else if( isNumeric( char ) ){\n            word = this.read( function( char ){\n                return !isNumeric( char );\n            } );\n            \n            this.tokens.push( new Literal( word ) );\n        \n        // Whitespace\n        } else if( isWhitespace( char ) ){\n            this.index++;\n        \n        // Error\n        } else {\n            this.throwError( '\"' + char + '\" is an invalid character' );\n        }\n        \n        word = '';\n    }\n    \n    return this.tokens;\n};\n\n/**\n * @function\n * @param {external:function} until A condition that when met will stop the reading of the buffer\n * @returns {external:string} The portion of the buffer read\n */\nLexer.prototype.read = function( until ){\n    var start = this.index,\n        char;\n    \n    while( this.index < this.buffer.length ){\n        char = this.buffer[ this.index ];\n        \n        if( until( char ) ){\n            break;\n        }\n        \n        this.index++;\n    }\n    \n    return this.buffer.slice( start, this.index );\n};\n\n/**\n * @function\n * @throws {Lexer~LexerError} When it executes\n */\nLexer.prototype.throwError = function( message ){\n    throw new LexerError( message );\n};\n\n/**\n * @function\n * @returns {external:Object} A JSON representation of the lexer\n */\nLexer.prototype.toJSON = function(){\n    var json = new Null();\n    \n    json.buffer = this.buffer;\n    json.tokens = this.tokens.map( function( token ){\n        return token.toJSON();\n    } );\n    \n    return json;\n};\n\n/**\n * @function\n * @returns {external:string} A string representation of the lexer\n */\nLexer.prototype.toString = function(){\n    return this.buffer;\n};\n\nexport { Lexer as default };"],"names":[],"mappings":"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","sourceRoot":"/source/"}